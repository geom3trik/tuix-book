<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tuix Guide</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Quick Start Guide</li><li class="chapter-item expanded "><a href="quick_start/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quick_start/creating_an_application.html"><strong aria-hidden="true">2.</strong> Creating an Application</a></li><li class="chapter-item expanded "><a href="quick_start/setting_window_properties.html"><strong aria-hidden="true">3.</strong> Setting Window Properties</a></li><li class="chapter-item expanded "><a href="quick_start/adding_a_widget.html"><strong aria-hidden="true">4.</strong> Adding a Button</a></li><li class="chapter-item expanded "><a href="quick_start/positioning_the_widget.html"><strong aria-hidden="true">5.</strong> Positioning the Button</a></li><li class="chapter-item expanded "><a href="quick_start/composing_widgets.html"><strong aria-hidden="true">6.</strong> Composing Widgets</a></li><li class="chapter-item expanded "><a href="quick_start/widget_styling.html"><strong aria-hidden="true">7.</strong> Styling the App</a></li><li class="chapter-item expanded "><a href="quick_start/custom_widget.html"><strong aria-hidden="true">8.</strong> Creating a Counter Widget</a></li><li class="chapter-item expanded "><a href="quick_start/handling_events.html"><strong aria-hidden="true">9.</strong> Handling Events</a></li><li class="chapter-item expanded "><a href="quick_start/reactivity_and_binding.html"><strong aria-hidden="true">10.</strong> Reactivity and Model Data</a></li><li class="chapter-item expanded "><a href="quick_start/lenses_and_binding.html"><strong aria-hidden="true">11.</strong> Lenses and Binding</a></li><li class="chapter-item expanded "><a href="quick_start/updating.html"><strong aria-hidden="true">12.</strong> Making the Counter Reusable</a></li><li class="chapter-item expanded affix "><li class="part-title">Layout</li><li class="chapter-item expanded "><a href="layout/stack_overview.html"><strong aria-hidden="true">13.</strong> Overview (Stack)</a></li><li class="chapter-item expanded "><a href="layout/child_properties.html"><strong aria-hidden="true">14.</strong> Child Properies</a></li><li class="chapter-item expanded "><a href="layout/parent_properties.html"><strong aria-hidden="true">15.</strong> Parent Properies</a></li><li class="chapter-item expanded "><a href="layout/grid_overview.html"><strong aria-hidden="true">16.</strong> Overview (Grid)</a></li><li class="chapter-item expanded "><a href="layout/stacks.html"><strong aria-hidden="true">17.</strong> Stacks</a></li><li class="chapter-item expanded "><a href="layout/positioning_text.html"><strong aria-hidden="true">18.</strong> Positioning Text</a></li><li class="chapter-item expanded "><a href="layout/layout_properties.html"><strong aria-hidden="true">19.</strong> Layout Properties</a></li><li class="chapter-item expanded affix "><li class="part-title">Events</li><li class="chapter-item expanded "><a href="events/chapter_1.html"><strong aria-hidden="true">20.</strong> Overview</a></li><li class="chapter-item expanded "><a href="events/events_and_messages.html"><strong aria-hidden="true">21.</strong> Events and Messages</a></li><li class="chapter-item expanded "><a href="events/event_propagation.html"><strong aria-hidden="true">22.</strong> Event Propagation</a></li><li class="chapter-item expanded "><a href="events/handling_events.html"><strong aria-hidden="true">23.</strong> Handling Events</a></li><li class="chapter-item expanded "><a href="events/window_events.html"><strong aria-hidden="true">24.</strong> Window Events</a></li><li class="chapter-item expanded affix "><li class="part-title">Styling</li><li class="chapter-item expanded "><a href="styling/overview.html"><strong aria-hidden="true">25.</strong> Overview</a></li><li class="chapter-item expanded "><a href="styling/inline_styling.html"><strong aria-hidden="true">26.</strong> Inline Styling</a></li><li class="chapter-item expanded "><a href="styling/shared_styling.html"><strong aria-hidden="true">27.</strong> Shared Styling</a></li><li class="chapter-item expanded "><a href="styling/style_properties.html"><strong aria-hidden="true">28.</strong> Style Properties</a></li><li class="chapter-item expanded "><a href="styling/selectors.html"><strong aria-hidden="true">29.</strong> Selectors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="styling/display.html"><strong aria-hidden="true">29.1.</strong> Display</a></li><li class="chapter-item expanded "><a href="styling/background.html"><strong aria-hidden="true">29.2.</strong> Background</a></li><li class="chapter-item expanded "><a href="styling/border.html"><strong aria-hidden="true">29.3.</strong> Border</a></li><li class="chapter-item expanded "><a href="styling/shadows.html"><strong aria-hidden="true">29.4.</strong> Shadows</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Bindng</li><li class="chapter-item expanded "><a href="binding/intro.html"><strong aria-hidden="true">30.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="binding/model.html"><strong aria-hidden="true">31.</strong> Model</a></li><li class="chapter-item expanded "><a href="binding/lens.html"><strong aria-hidden="true">32.</strong> Lens</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tuix Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tuix"><a class="header" href="#tuix">Tuix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This quick-start guide will cover the basic concepts for getting started with tuix. By the end of the guide we will have built a simple counter app with buttons to increment and decrement the count, as well as two labels showing different views on the same data. Here's a screenshot of the finished app:</p>
<p align="center"><img src="quick_start/../images/quick_guide/counter_reactive.png" alt="counter app"></p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Start by creating a new rust binary project in a location of your choosing by running the following command:</p>
<pre><code class="language-sh">cargo new tuix_counter
</code></pre>
<p>This should create a new folder called <code>tuix_counter</code> which should contain: a <code>src</code> directory with a <code>main.rs</code> file, and a <code>Cargo.toml</code> file.</p>
<p>Open the <code>Cargo.toml</code> file in your editor of choice and add the following under the <code>[dependencies]</code> section:</p>
<pre><code class="language-sh">tuix = { git = &quot;https://github.com/geom3trik/tuix.git&quot;, branch = &quot;reactive&quot; }
</code></pre>
<p>This tells rust to include tuix as an external dependency.</p>
<p>Next, open the <code>main.rs</code> file and remove the hello world example code. When you're ready, move on to the next section where we'll build the simplest tuix app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-an-application"><a class="header" href="#creating-an-application">Creating an Application</a></h1>
<p>Add the following code to the <code>main.rs</code> file:</p>
<pre><pre class="playground"><code class="language-rust">extern crate tuix;
use tuix::*;

fn main() {
    let mut app = Application::new(WindowDescription::new(), |state, window| {});

    app.run();
}
</code></pre></pre>
<p>This is the simplest possible tuix app.</p>
<p>Build and run this code by executing the following command:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<p align="center"><img src="quick_start/../images/quick_guide/tuix_app.png" height="300" alt="tuix app"></p>
<p>You should see an empty gray window appear. Yay! Now to explain what the code does: </p>
<p>The first argument passed to <code>Application::new()</code> is a new instance of a <code>WindowDescription</code>. This allows us to set the initial properties of the root window created for us by tuix. Currently, tuix can only create single window applications, but multiwindow is in the works!</p>
<p>The second argument passed to the new method is a closure which provides us with two arguments:</p>
<ol>
<li>
<p><code>state</code> - This is a mutable reference to the UI <code>State</code>, which represents the 'global' data of the widgets in a gui application, such as layout and style properties. A mutable reference to state is passed around when building widgets, handling events, and drawing widgets.</p>
</li>
<li>
<p><code>window</code> - This is an <code>Entity</code> id to the window widget created for us by tuix. Every widget has an entity id which is used with state to modify UI properties.</p>
</li>
</ol>
<p>In the next section we'll cover changing window properties like the title and inner size.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-window-properties"><a class="header" href="#setting-window-properties">Setting Window Properties</a></h1>
<p>Window properties can be set using the <code>WindowDescription</code>, which is the second argument of the closure passed to <code>Application::new()</code>.</p>
<p>Lets add a custom title to our application window. It will eventually be a counter, so let's go with that:</p>
<pre><pre class="playground"><code class="language-rust">extern crate tuix;
use tuix::*;

fn main() {
    let app = Application::new(
        WindowDescription::new().with_title(&quot;Counter&quot;), 
        |state, window|{}
    );

    app.run();
}
</code></pre></pre>
<p>Using the builder pattern, setting window properties can be chained together. Let's change the size of the window to just 400 by 100. We don't need all that space for a simple counter:</p>
<pre><pre class="playground"><code class="language-rust">extern crate tuix;
use tuix::*;

fn main() {
    let app = Application::new(
        WindowDescription::new().with_title(&quot;Counter&quot;)
        .with_inner_size(400, 100),
        |state, window|{}
    );

    app.run();
}
</code></pre></pre>
<p align="center"><img src="quick_start/../images/quick_guide/window_props.png" alt="tuix app"></p>
<p>To see the full list of window properties that can be set, see the docs page on <code>WindowDescription</code>. This will do for now, let's move on to adding widgets to our application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-button"><a class="header" href="#adding-a-button">Adding a Button</a></h1>
<p>For our counter we know we will need two buttons (for increment and decrement) and at least one label (to show the value). But to start with let's just add one of the buttons to our window with the following code:</p>
<pre><pre class="playground"><code class="language-rust">extern crate tuix;
use tuix::*;

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Counter&quot;)
        .with_inner_size(400, 100);
    let app = Application::new(window_description, |state, window| {
            
        // Add an Button widget
        Button::with_label(&quot;Increment&quot;)
            .build(state, window, |builder| builder);
    });

    app.run();
}

</code></pre></pre>
<p>To add the button widget we create a new instance with <code>Button::with_label(&quot;Increment&quot;)</code>. This creates a new button and also gives it some text to use as a label. If we didn't want any text we could have also used the <code>::new()</code> method.</p>
<p>The button instance is then built into the app with <code>.build(state, window, |builder| builder)</code>. </p>
<ul>
<li>
<p>The first argument, <code>state</code>, is a mutable reference to <code>State</code> from the application closure. </p>
</li>
<li>
<p>The second argument is the entity id of the parent widget, in this case the window widget, which is the second argument of the application closure. Each widget has an <code>Entity</code> id which can be used to get and set various widget properties stored in <code>State</code>, and used to identify parent widgets to their children.</p>
</li>
<li>
<p>The third argument is a closure which provides us with a builder we can use to set properties of the newly created widget, which we'll cover in a moment.</p>
</li>
</ul>
<p>If you build and run this code though you will see an almost empty window with just the text <code>&quot;Increment&quot;</code> in the top left corner:</p>
<p align="center"><img src="quick_start/../images/quick_guide/unstyled_button.png" alt="unstyled button"></p>
<p>This is because the <code>Button</code> widget has no built-in styling. To see the button, we can add a width, height, and background color using the builder like so:</p>
<pre><pre class="playground"><code class="language-rust">extern crate tuix;
use tuix::*;

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Counter&quot;)
        .with_inner_size(400, 100);
    let app = Application::new(window_description, |state, window| {
            
            Button::with_label(&quot;Increment&quot;).build(state, window, |builder| {
                builder
                    .set_width(Pixels(100.0))
                    .set_height(Pixels(30.0))
                    .set_background_color(Color::rgb(20, 80, 200))
            });
        
        },
    );

    app.run();
}
</code></pre></pre>
<p>This will produce a nice blue button in the top left corner of the window with a width of 100 pixels and a height of 30 pixels, and with a text showing <code>&quot;Increment&quot;</code>. Note that the text is not aligned in the center of the button. This will be fixed later in the guide during styling.</p>
<p align="center"><img src="quick_start/../images/quick_guide/styled_button.png" alt="tuix app"></p>
<p>In the next section we will look at how to move our button into a more interesting position.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="positioning-the-button"><a class="header" href="#positioning-the-button">Positioning the Button</a></h1>
<p>Okay so we have a button, but it's up in the top left when really it should be in the center. If you're coming from web dev then you might be thinking, &quot;oh no, not centering!&quot;. But fear not, it's super easy in tuix.</p>
<p>The way we center a widget in tuix is to add stretch spacing to all sides:</p>
<pre><pre class="playground"><code class="language-rust">extern crate tuix;
use tuix::*;

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Counter&quot;)
        .with_inner_size(400, 100);
    let app = Application::new(window_description, |state, window| {
            
            Button::with_label(&quot;Increment&quot;).build(state, window, |builder| {
                builder
                    .set_width(Pixels(100.0))
                    .set_height(Pixels(30.0))
                    .set_background_color(Color::rgb(20, 80, 200))
                    .set_space(Stretch(1.0))
            });
        
        },
    );

    app.run();
}
</code></pre></pre>
<p>Running this code shows our button now in the center. Easy peasy!</p>
<p align="center"><img src="quick_start/../images/quick_guide/centered_button.png" alt="tuix app"></p>
<p>Hang on though, what the heck is stretch space?</p>
<p>Okay, so while layout in tuix is highly customizable and flexible, it's quite a big topic for a quick start guide. So for now, here's a short description, and a more detailed guide can be found the the <a href="quick_start/../layout/stack_overview.html">layout section</a>.</p>
<ul>
<li>Widgets are positioned by their parent into a row, column, or grid with their siblings, determined by parent <a href="quick_start/../layout/stacks.html">layout-type</a>.</li>
<li>Widgets can be moved, relative to their stack or grid position, by adding space to each of their sides, <a href="quick_start/../layout/stacks.html">left</a>, <a href="quick_start/../layout/stacks.html">right</a>, <a href="quick_start/../layout/stacks.html">top</a>, and <a href="quick_start/../layout/stacks.html">bottom</a>, (or <a href="quick_start/../layout/stacks.html">space</a> for all four at once).</li>
<li>Space comes in four varieties:
<ul>
<li>auto - can be overriden by parent</li>
<li>stretch - a proportion of the remaining free space</li>
<li>percentage - a proportion of the parent width/height</li>
<li>pixels - an exact number of pixels</li>
</ul>
</li>
<li>The parent can apply space to all of its children, if their corresponding space properties are set to auto (which is the default unless otherwise set/specified), using <a href="quick_start/../layout/stacks.html">child-left</a>, <a href="quick_start/../layout/stacks.html">child-right</a>, <a href="quick_start/../layout/stacks.html">child-top</a>, <a href="quick_start/../layout/stacks.html">child-bottom</a>, or <a href="quick_start/../layout/stacks.html">child-space</a>. Also specified with the same four possible units.</li>
<li>The parent can also apply horizontal space between its children, with <a href="quick_start/../layout/stacks.html">col-between</a>, as vertical space, with <a href="quick_start/../layout/stacks.html">row-between</a>. All specified with the same for possible units. </li>
</ul>
<p>There are more rules but to keep things short the above overview should be sufficient for the rest of this quick-guide.</p>
<p>By adding <code>stretch</code> space to each side of the button we are telling tuix to add space which fills the available free space, which causes the button to become centered.</p>
<p>In the next section we'll look at adding more widgets and composing them together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composing-widgets"><a class="header" href="#composing-widgets">Composing Widgets</a></h1>
<p>So far our counter has only a single button. Let's add another button and a label, as well as a <code>Row</code> widget to be the parent of our buttons and label. A <code>Row</code> widget, as the name suggests, lays out its children in a horizontal row:</p>
<pre><pre class="playground"><code class="language-rust">extern crate tuix;
use tuix::*;

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Counter&quot;)
        .with_inner_size(400, 100);
    let app = Application::new(window_description, |state, window| {
        
        let row = Row::new().build(state, window, |builder| builder);

        Button::with_label(&quot;Decrement&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .set_background_color(Color::rgb(20,80,200))
                .set_space(Stretch(1.0))
        );

        Button::with_label(&quot;Increment&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .set_background_color(Color::rgb(20,80,200))
                .set_space(Stretch(1.0))
        );

        Label::new(&quot;0&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .set_background_color(Color::rgb(50,50,50))
                .set_space(Stretch(1.0))
        );

    });

    app.run();
}
</code></pre></pre>
<p>Building the second button widget works in the same way as the first. However, notice that the building of both buttons now uses <code>row</code> as the parent. This is the <code>Entity</code> id of the <code>Row</code> widget instance and is returned by its <code>.build(...)</code> method. The row uses the <code>window</code> as its parent.</p>
<p>Composing these widgets like this forms a tree, where each widget has a single parent and zero or more children. In tuix, this tree is used to propagate events as well as to draw the elements in the correct order. Below is a diagram depicting the current tree of widgets:</p>
<p align="center"><img src="quick_start/../images/quick_guide/basic_tree.png" alt="tuix app"></p>
<p>Running this code produces:</p>
<p align="center"><img src="quick_start/../images/quick_guide/composing_widgets.png" alt="tuix app"></p>
<p>Woah! All our widgets are spaced out across the window! Can you see why?</p>
<p>The default width and height of a widget, if not specified, is to stretch to fill the available space. So the <code>Row</code> widget has stretched to fill the window, although we can't see it directly because it has no background color.</p>
<p>The buttons and label all have space around them set to stretch, which results in equal spacing between them, as well as centering them as a collection within the row.</p>
<p>Let's remove the calls to <code>set_space</code> on each of the widgets and add two new methods on the builder for the row:</p>
<pre><code class="language-rs">Row::new().build(state, window, |builder|
    builder
        .set_child_space(Stretch(1.0))
        .set_col_between(Pixels(10.0))
);
</code></pre>
<p>This sets the space around all of the children of the row (our buttons and label) to stretch, and also sets a fixed horizontal spacing between them of 10 pixels:</p>
<p align="center"><img src="quick_start/../images/quick_guide/correctly_spaced.png" alt="tuix app"></p>
<p>In the nect section we'll add some styling to our app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling-the-app"><a class="header" href="#styling-the-app">Styling the App</a></h1>
<p>Our app now consists of two blue buttons and a gray label. Let's be honest, that doesn't look great and it doesn't feel like a GUI yet. The buttons don't even do anything when you hover and press them.</p>
<p>To fix this we will add style to our widgets. Tuix has two forms of styling:</p>
<ol>
<li>inline</li>
<li>shared</li>
</ol>
<p>So far we have defined our style properties directly on the widgets using the builder, also known as <em>inline</em> styling. Tuix also offers the ability to define style rules to allow <em>shared</em> styling between multiple widgets. The widgets affected by these shared style rules are determined by <em>selectors</em> which should be familiar to web developers using css and work in much the same way.</p>
<p>Before we can add a shared style we need to give the widgets some class names, using the <code>.class()</code> method on the builder, so we can target them with selectors:</p>
<pre><code class="language-rs">Button::with_label(&quot;Decrement&quot;).build(state, row, |builder| 
    builder
        .set_width(Pixels(100.0))
        .set_height(Pixels(30.0))
        .set_background_color(Color::rgb(20,80,200))
        .set_space(Stretch(1.0))
        .class(&quot;decrement&quot;)
);

Button::with_label(&quot;Increment&quot;).build(state, row, |builder| 
    builder
        .set_width(Pixels(100.0))
        .set_height(Pixels(30.0))
        .set_background_color(Color::rgb(20,80,200))
        .set_space(Stretch(1.0))
        .class(&quot;increment&quot;)
);
</code></pre>
<p>Here we've added <code>&quot;increment&quot;</code> and <code>&quot;decrement&quot;</code> class names to our buttons. Now we can write some css to affect the styling of our widgets. Add the following to the top of the <code>main.rs</code> file just below the <code>use tuix::*</code> line:</p>
<pre><code class="language-rs">const STYLE: &amp;str = r#&quot;
    button {
        border-radius: 3px;
        child-space: 1s;
    }

    button.increment {
        background-color: #2e7d32;
        border-radius: 3px;
    }

    button.increment:hover {
        background-color: #60ad5e;
    }

    button.increment:active {
        background-color: #005005;
    }
    
    button.decrement {
        background-color: #c62828;
        border-radius: 3px;
    }

    button.decrement:hover {
        background-color: #ff5f52;
    }

    button.decrement:active {
        background-color: #8e0000;
    }

    label {
        background-color: #404040;
        border-color: #606060;
        border-width: 1px;
        child-space: 1s;
    }
&quot;#;
</code></pre>
<p>Since this isn't a css guide, we won't go into detail on how this works. But more information can be found in the <a href="quick_start/../styling/overview.html">styling</a> section of the book.</p>
<p>Now we need to add the stylesheet to the app by calling <code>state.add_theme(STYLE)</code>. Typically this is done in the application closure before creating any widgets.</p>
<p>Note also that <em>inline</em> properties override <em>shared</em> properties, so for the buttons to be affected we need to remove the calls which set their color on the builder. </p>
<p>A screenshot of the result is shown below. Note also that we've now fixed the text alignment within the widgets using the <code>child-space</code> property, which applies to both child widgets and text.</p>
<p align="center"><img src="quick_start/../images/quick_guide/styling_widgets.png" alt="tuix app"></p>
<p>And the complete code is:</p>
<pre><pre class="playground"><code class="language-rust">extern crate tuix;
use tuix::*;

const STYLE: &amp;str = r#&quot;
    button {
        border-radius: 3px;
        child-space: 1s;
    }

    button.increment {
        background-color: #2e7d32;
        border-radius: 3px;
    }

    button.increment:hover {
        background-color: #60ad5e;
    }

    button.increment:active {
        background-color: #005005;
    }
    
    button.decrement {
        background-color: #c62828;
        border-radius: 3px;
    }

    button.decrement:hover {
        background-color: #ff5f52;
    }

    button.decrement:active {
        background-color: #8e0000;
    }

    label {
        background-color: #404040;
        border-color: #606060;
        border-width: 1px;
        child-space: 1s;
    }
&quot;#;

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Counter&quot;)
        .with_inner_size(400, 100);
    let app = Application::new(window_description, |state, window| {

        state.add_theme(STYLE);
        
        let row = Row::new().build(state, window, |builder| 
            builder
                .set_child_space(Stretch(1.0))
                .set_col_between(Pixels(10.0))
        );

        Button::with_label(&quot;Decrement&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .class(&quot;decrement&quot;)
        );

        Button::with_label(&quot;Increment&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .class(&quot;increment&quot;)
        );

        Label::new(&quot;0&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
        );

    });

    app.run();
}

</code></pre></pre>
<p>Tuix also offers the ability to define styles in separate stylesheet files with .css extensions, which can then be included with the <code>include_str!</code> macro. However, although some of the style properties available in tuix share the same name as css properties, in general the available style properties are different.</p>
<p>Alternatively, <code>state.add_stylesheet()</code> can be used to add a stylesheet dynamically by specifying the path to the css file. This allows for hot reloading of the stylesheet using the F5 key, however, the css file must be shipped with the executable.</p>
<p>In the next section, we'll move what we've made so far into its own custom widget with a variable for the actual count.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-counter-widget"><a class="header" href="#creating-a-counter-widget">Creating a Counter Widget</a></h1>
<p>Our code so far produces something that <em>looks</em> like it could be a counter but it doesn't do anything yet. In the next section we'll dive into events and how we can use them to add some functionality to the app, but first we need to cover the concept of custom widgets.</p>
<p>So far we've used some of the built-in widgets in tuix to build our app, but it's time to build our own <code>Counter</code> widget to contain what we've built so far, and we'll also need it to react to events.</p>
<p>Start by creating a struct called <code>Counter</code>, and we'll derive <code>Default</code> so we don't need to write a constructor:</p>
<pre><code class="language-rs">#[derive(Default)]
struct Counter {
    value: i32,
}
</code></pre>
<p>Our counter contains the actual count value, an <code>i32</code>, which we'll need for later.</p>
<p>To make our <code>Counter</code> struct a widget we just need to implement the <code>Widget</code> trait for it like so:</p>
<pre><code class="language-rs">impl Widget for Counter {
    type Ret = Entity;
    type Data = ();

    fn on_build(&amp;mut self, state: &amp;mut State, entity: Entity) -&gt; Self::Ret {
        entity
    }
}
</code></pre>
<p>Let's take a moment to break down the pieces of the <code>Widget</code> trait. There are two associated types, <code>Ret</code> and <code>Data</code>:</p>
<ul>
<li>The <code>Ret</code> associated type is used to specify what should be returned when the widget is built. Typically a widget will return its <code>Entity</code> id, but a widget could be made up of several sub-widgets, some of which the user may need access to when building. In these cases the <code>Ret</code> type can be set to a tuple, such as <code>(Entity, Entity)</code>. For our counter we'll just return an <code>Entity</code>.</li>
<li>The <code>Data</code> associated type is used by the binding system, which for now we will save for a later section of the guide. In the meantime you can set this to <code>()</code>.</li>
</ul>
<p>The <code>Widget</code> trait has a few methods, but only the <code>on_build()</code> method is required to be implemented, and must return the <code>Ret</code> associated type. Usually this will be the entity id of the widget which is passed as an argument to the function.</p>
<p>The <code>on_build</code> method is called once when the widget is first built. So when we called <code>build()</code> on the buttons and label, their respective <code>on_build()</code> methods were called. It is within this function that we can build the components which will make up our widget. Note also that this method provides a mutable reference to <code>Self</code>, so we can access fields like our counter value, and a mutable reference to <code>State</code>, so we can set inline style properties of the widget at build time, using the <code>entity</code> id. </p>
<p>For the counter, we'll move the row, buttons, and label into the body of this method, making sure to change the parent of the row from <code>window</code> to <code>entity</code> (the id given to the <code>Counter</code> widget when it is built).</p>
<pre><code class="language-rs">impl Widget for Counter {
    type Ret = Entity;
    type Data = ();

    fn on_build(&amp;mut self, state: &amp;mut State, entity: Entity) -&gt; Self::Ret {

        // Note the change from window to entity
        let row = Row::new().build(state, entity, |builder| 
            builder
                .set_child_space(Stretch(1.0))
                .set_col_between(Pixels(10.0))
        );

        Button::with_label(&quot;Decrement&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .class(&quot;decrement&quot;)
        );

        Button::with_label(&quot;Increment&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .class(&quot;increment&quot;)
        );

        Label::new(&quot;0&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
        );

        entity
    }
}

</code></pre>
<p>Now that we have a counter wiget, which contains our buttons and label, how do we use it? Well, the same as any other widget! Where we had the row, buttons, and label, insert the following line:</p>
<pre><code class="language-rs">Counter::default().build(state, window, |builder| builder);
</code></pre>
<p>As with the row widget, the counter by default will fill the available space, and running the code appears to produce the same result as we had before:</p>
<p align="center"><img src="quick_start/../images/quick_guide/styling_widgets.png" alt="tuix app"></p>
<p>That seemed like a lot of work for no noticable change. However, it's in the next section that things get interesting for our counter widget.</p>
<p>Also, here is the complete code so far:</p>
<pre><pre class="playground"><code class="language-rust">extern crate tuix;
use tuix::*;

const STYLE: &amp;str = r#&quot;

    button {
        border-radius: 3px;
        child-space: 1s;
    }

    button.increment {
        background-color: #2e7d32;
        border-radius: 3px;
    }

    button.increment:hover {
        background-color: #60ad5e;
    }

    button.increment:active {
        background-color: #005005;
    }
    
    button.decrement {
        background-color: #c62828;
        border-radius: 3px;
    }

    button.decrement:hover {
        background-color: #ff5f52;
    }

    button.decrement:active {
        background-color: #8e0000;
    }

    label {
        background-color: #404040;
        border-color: #606060;
        border-width: 1px;
        child-space: 1s;
    }
&quot;#;

#[derive(Default)]
struct Counter {
    value: i32,
}

impl Widget for Counter {
    type Ret = Entity;
    type Data = ();

    fn on_build(&amp;mut self, state: &amp;mut State, entity: Entity) -&gt; Self::Ret {
        let row = Row::new().build(state, entity, |builder| 
            builder
                .set_child_space(Stretch(1.0))
                .set_col_between(Pixels(10.0))
        );

        Button::with_label(&quot;Decrement&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .class(&quot;decrement&quot;)
        );

        Button::with_label(&quot;Increment&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .class(&quot;increment&quot;)
        );

        Label::new(&quot;0&quot;).build(state, row, |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
        );

        entity
    }
}

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Counter&quot;)
        .with_inner_size(400, 100);
    let app = Application::new(window_description, |state, window| {

        state.add_theme(STYLE);
        
        Counter::default().build(state, window, |builder| builder);

    });

    app.run();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>Alright, we've got a nice looking counter but how do we make it do something? Time for some events!</p>
<h2 id="handling-events"><a class="header" href="#handling-events">Handling Events</a></h2>
<p>The <code>Widget</code> trait has another method called <code>on_event</code> which will allow us to react to events and change the internal data (the counter value) and child widgets (the buttons and label) of our counter. Add the following to the implementation of the <code>Widget</code> trait for our counter, right below the <code>on_build()</code> method:</p>
<pre><code class="language-rs">fn on_event(&amp;mut self, state: &amp;mut State, entity: Entity, event: &amp;mut Event) {

}
</code></pre>
<p>Note that the method signature is very similar to <code>on_build</code> but, instead of returning something, there's an extra argument, a mutable reference to some <code>Event</code>.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>So what is the event? Well an event is a struct which contains a <code>Message</code> and some meta data about the event, like its origin and target entities. Okay so what's a <code>Message</code>? Well a message is a dynamic object pointer to some user defined type. In fact it can be any type as long as it implements <code>PartialEq</code>. So let's make a message type which we can respond to. Add this just before we declare the <code>Counter</code> struct:</p>
<pre><code class="language-rs">#[derive(PartialEq)]
pub enum CounterEvent {
    Increment,
    Decrement,
}
</code></pre>
<p>Now we can modify the <code>on_event</code> method to do something when it receives this type of event:</p>
<pre><code class="language-rs">fn on_event(&amp;mut self, state: &amp;mut State, entity: Entity, event: &amp;mut Event) {
    if let Some(counter_event) = event.message.downcast() {
        match counter_event {
            CounterEvent::Increment =&gt; {
                self.value += 1;
            }

            CounterEvent::Decrement =&gt; {
                self.value -= 1;
            }
        }
    }
}

</code></pre>
<p>Here we attempt to <a href="https://bennetthardwick.com/rust/downcast-trait-object/">downcast</a> the message within the event to the <code>ConterEvent</code> type, and on success match against the options, incrementing or decrementing the counter value in response. </p>
<p>Okay, so our counter widget can now respond to counter events, but how does it get them? Something needs to send those events. How about those buttons?</p>
<h2 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h2>
<p>To send events when our buttons are pressed we need another new concept, which is callbacks. Most widgets allow you to set a callback (a closure) which will run when the widget is interacted with or changes state. In this case it's probably best to learn by example so change the decrement button to look like this:</p>
<pre><code class="language-rs">Button::with_label(&quot;Decrement&quot;)
    .on_press(|data: &amp;mut Button, state: &amp;mut State, button: Entity|{
        button.emit(state, CounterEvent::Decrement);
    })
    .build(state, row, |builder|
        builder
            .set_width(Pixels(100.0))
            .set_height(Pixels(30.0))
            .class(&quot;decrement&quot;)
    )
</code></pre>
<p>For clarity I've included the argument types but these can be inferred by the rust compiler. Notice that the arguments shadow those of <code>on_build</code> and the first 3 of <code>on_event</code>, providing a mutable reference to the widget (<code>Button</code> in this case), a mutable reference to <code>State</code>, and the <code>Entity</code> id of the button.</p>
<p>Using the button id and state we call <code>emit()</code> to send a <code>CounterEvent::Decrement</code> event. As the name suggests, this callback will be triggered when the button is pressed.</p>
<p>But where does the event go? Remember that tree which was mentioned before? Well, by default, events are sent <em>up</em> the tree, hitting every ancestor on its way to the root (the window). Because the button is a decendent of the counter (counter -&gt; row -&gt; button), the counter will receive the event after the button is pressed. The figure below depicts the tree of widgets with our custom counter widget:</p>
<p align="center"><img src="quick_start/../images/quick_guide/counter_tree.png" alt="tuix app"></p>
<p>We're almost there. Adding in the callback for the increment button (left as an exercise for the reader), we now have a counter whose value will change when the buttons are pressed! Hang on though... nothing seems to be happening... the label still shows zero. Ah, we need to make two more modifications to update the label.</p>
<p>First, we need to store the entity id of the label in the counter so we can access it in <code>on_event</code>. Change the <code>Counter</code> to:</p>
<pre><code class="language-rs">#[derive(Default)]
struct Counter {
    value: i32,
    label: Entity,
}
</code></pre>
<p>and then the label to:</p>
<pre><code class="language-rs">// We now assign the output of the label build to the label variable
self.label = Label::new(&quot;0&quot;).build(state, row, |builder| 
    builder
        .set_width(Pixels(100.0))
        .set_height(Pixels(30.0))
);
</code></pre>
<p>Finally, we need to update the label text in the <code>on_event</code> method:</p>
<pre><code class="language-rs">fn on_event(&amp;mut self, state: &amp;mut State, entity: Entity, event: &amp;mut Event) {
    if let Some(counter_event) = event.message.downcast() {
        match counter_event {
            CounterEvent::Increment =&gt; {
                self.value += 1;
                self.label.set_text(state, &amp;self.value.to_string());
            }

            CounterEvent::Decrement =&gt; {
                self.value -= 1;
                self.label.set_text(state, &amp;self.value.to_string());
            }
        }
    }
}
</code></pre>
<p>We can set the label this way because every widget has a text property which can be set through its entity id. If this was a more complicated widget, such as a slider, then we would update it using an event targeted at the widget. For example, we could send a <code>SliderEvent::SetValue()</code> event to a slider widget to update it.</p>
<p>We finally have a working counter!</p>
<p>You can find the full code for this guide so far in the <code>examples/counter.rs</code> file in the tuix repository. Run with <code>cargo run --release --example counter</code>. </p>
<p align="center"><img src="quick_start/../images/quick_guide/counter.png" alt="tuix app"></p>
<p>In the next section we'll start to look at how we can make our counter widget more re-usable with some reactivity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactivity-and-model-data"><a class="header" href="#reactivity-and-model-data">Reactivity and Model Data</a></h1>
<p>In the previous sections we built a simple counter widget. This widget could now be embedded into a more complex gui and work just fine, keeping its own count. However, this isn't always the most practical solution. What if we had two counters and we wanted them to be synced to the same value? Okay we could send some events from one to the other but this isn't always so easy, especially if the widgets are 'far' away from each other within the tree.</p>
<p>The example of two counters being synced is a bit contrived but the issue of sharing application data between widgets is important and leads to reactivity as the solution. What is reactivity? For tuix, reactivity is the ability for widgets to 'bind' to application data, so that when the data changes, all the bound widgets update their state automatically. It's this ability which allows for more scalable applications.</p>
<p>In this section and the next we will modify our counter by adding another separate label, and syncing both our counter and the label to some shared data. </p>
<h2 id="model-data"><a class="header" href="#model-data">Model Data</a></h2>
<p>We'll start with the counter example as we left it in the previous section. </p>
<p>First we need to add a struct for the shared application data:</p>
<pre><code class="language-rs">#[derive(Default)]
struct CounterState {
    value: i32
}
</code></pre>
<p>Just like the counter widget before, this struct contains an <code>i32</code> value to represent the count.</p>
<p>To allow this data to be embedded within the gui tree we need to implement the <code>Model</code> trait for it:</p>
<pre><code class="language-rs">impl Model for CounterState {

}
</code></pre>
<p>The <code>Model</code> trait is similar to the <code>Widget</code> trait but is used for non-visual data. It also contains an <code>on_event</code> method to respond to events, and allows us to <code>build</code> the data into the tree. </p>
<p>Modify the implmentation of <code>Model</code> on <code>CounterState</code> so that it updates the value in response to a <code>CounterEvent</code> within the <code>on_event</code> method, just like we did for our custom counter widget before:</p>
<pre><code class="language-rs">impl Model for CounterState {
    fn on_event(&amp;mut self, state: &amp;mut State, entity: Entity, event: &amp;mut Event) {
        if let Some(counter_event) = event.message.downcast() {
            match counter_event {
                CounterEvent::Increment =&gt; {
                    self.value += 1;
                    entity.emit(state, BindEvent::Update);
                }

                CounterEvent::Decrement =&gt; {
                    self.value -= 1;
                    entity.emit(state, BindEvent::Update);
                }
            }
        }        
    }
}
</code></pre>
<p>Note the call to emit a <code>BindEvent::Update</code> event at each point the value is changed. Tuix doesn't (yet) provide a built-in method to detect changes of application data, so this event must be sent manually so bound widgets so they receive an update.</p>
<h3 id="building-model-data"><a class="header" href="#building-model-data">Building Model Data</a></h3>
<p>Now that we have our application data in a separate struct we need to build it into the app. Insert this code into the application closure above the call to create and build the counter widget:</p>
<pre><code class="language-rs">let app_data = CounterState::default().build(state, window);
</code></pre>
<p>Note that the <code>build</code> function on <code>CounterState</code> does not contain a builder closure because this isn't a visual widget.</p>
<p>Next, make sure to change the parent of the counter to the application data:</p>
<pre><code class="language-rs">Counter::default().build(state, app_data, |builder| builder);
</code></pre>
<p>We have now inserted the app data just below the root of the application (the window) but above everything else. This means that any events that are sent up from widgets in the app will make their way to the app data thanks to it being an ancestor of everything below it. </p>
<p>Pressing the buttons of the counter will now modify the app data, but the label is still showing the internal value of the <code>Counter</code>. In the next section we'll modify our counter to remove the internal value and hook it up to our shared app data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lenses-and-binding"><a class="header" href="#lenses-and-binding">Lenses and Binding</a></h1>
<p>In the previous section we built some application data near the root of our gui app, but pressing the counter buttons still displays the internal value of our counter widget. </p>
<p>Let's remove the <code>on_event</code> of the <code>Counter</code> and the <code>value</code> field as well. Now the counter contains no count value, so we need to hook it up to the app data count value instead. </p>
<p>First, modify the declaration of the <code>CounterState</code> struct to add the <code>Lens</code> derive macro like so:</p>
<pre><code class="language-rs">#[derive(Default, Lens)]
struct CounterState {
    value: i32,
}
</code></pre>
<p>We'll go over lenses and what the <code>Lens</code> derive macro is doing in more detail in a moment, but let's take a look at binding our label to the counter value.</p>
<h2 id="binding"><a class="header" href="#binding">Binding</a></h2>
<p>With the <code>Lens</code> derive we can now bind the label in our counter to the value in the counter state with the <code>bind</code> method. Change the label to the following:</p>
<pre><code class="language-rs">self.label = Label::new(&quot;0&quot;)
    .bind(CounterState::value, |value| value.to_string())
    .build(state, row, |builder| 
        builder
            .set_width(Pixels(100.0))
            .set_height(Pixels(30.0))
    );
</code></pre>
<p>Let's break down what's going on here. The <code>bind</code> method is placed between the creation of the label instance and the call to <code>build</code>. It has two arguments, a lens and a closure:</p>
<ol>
<li>
<p>The first argument is a lens. We'll cover it in a moment but for now you can think of it as something which 'selects' a piece of a larger structure, in this case the <code>value</code> field of the <code>CounterState</code> struct.</p>
</li>
<li>
<p>The second argument is a closure which acts as a converter for the lensed data. The counter value is an <code>i32</code> but the label expects a <code>String</code>, so we use the <code>.to_string()</code> method to convert the value to the expected type.</p>
</li>
</ol>
<h2 id="lenses"><a class="header" href="#lenses">Lenses</a></h2>
<p>At first glance the lens argument of the <code>bind()</code> method seems a bit magical. How are we accessing the value with <code>CounterState::value</code>? That doesn't seem like valid rust code. There's a few things going on here which are hidden by the <code>Lens</code> derive macro, so let's break it down. </p>
<p>A lens, at its core, is nothing more than a function which takes some data as input and returns a piece of that data as output, usually as references. In this case it would take an reference to some <code>CounterState</code> and return a reference to the <code>value</code>. This function is actually a method on a <code>Lens</code> trait, which looks something like this:</p>
<pre><code class="language-rs">pub trait Lens {
    type Source;
    type Target;

    fn view&lt;'a&gt;(&amp;self, data: &amp;'a Self::Source) -&gt; &amp;'a Self::Target;
}
</code></pre>
<p>The derive macro creates for us a zero-sized static type and then implments this <code>Lens</code> trait on it, which might look something like this:</p>
<pre><code class="language-rs">pub struct SomeGeneratedType;

impl Lens for SomeGeneratedType {
    type Source = CounterState;
    type Target = i32;

    fn view&lt;'a&gt;(&amp;self, data: &amp;'a AppData) -&gt; &amp;'a i32 {
        &amp;data.value
    }
}
</code></pre>
<p>The other thing that the derive macro does is to create a static instance of the generated type, with the same name as the field (<code>value</code>), within a module called <code>CounterState</code>. This is what allows us to use <code>CounterState::value</code> to refer to the lens.</p>
<h2 id="binding-another-label"><a class="header" href="#binding-another-label">Binding Another Label</a></h2>
<p>Now when we run the code we seemingly get the same counter behaviour as before. The buttons update the value, via events, and the label receives the new value and updates its display. So why did we do this? Well, now we can do something more interesting, like bind another widget to the same value and display it in a different way, like printing the value as english text. Add the following dependency to the <code>Cargo.toml</code> file:</p>
<pre><code class="language-sh">english-numbers = &quot;0.3.3&quot;
</code></pre>
<p>Then add a label to the application below the counter with the following <code>bind</code> method:</p>
<pre><code class="language-rs">Label::new(&quot;Zero&quot;)
    .bind(CounterState::value, |value| english_numbers::convert_all_fmt(*value as i64))
    .build(state, data_widget, |builder| 
        builder
            .set_space(Pixels(5.0))
    );
</code></pre>
<p>We bind the label to the same value and use the conversion closure to call a method from the <code>english_numbers</code> crate to convert the value to an english word. Now when the buttons are pressed to increment and decrement the counter, both labels update to show the value in two different ways!</p>
<p align="center"><img src="quick_start/../images/quick_guide/counter_reactive.png" alt="tuix app"></p>
<p>In the next section we'll look at how we can make our counter widget more re-usable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-the-counter-reusable"><a class="header" href="#making-the-counter-reusable">Making the Counter Reusable</a></h1>
<p>Okay so we've got a reactive counter. It's reactive because when the value changes, via a button press, both labels update to show the new value without us having to explicitely send events to them.</p>
<p>However, with the way we've done it, our counter widget can't be used in another application unless it too has the same <code>CounterState</code> application data. We need to make our counter more generic.</p>
<p>When using our <code>Counter</code> widget in an app we won't have access to the label as it's built into the widget. So instead of binding to the label, we need to be able to bind to the counter widget itself.</p>
<h2 id="the-data-associated-type"><a class="header" href="#the-data-associated-type">The Data Associated Type</a></h2>
<p>This is where the <code>Data</code> associated type comes in from the <code>Widget</code> trait, which we previously set to <code>()</code>. This associated type is used to specify the type of data a widget is expected to receive. It was mentioned before that a <code>Label</code> expects a <code>String</code>, which is because its associated data type is <code>type Data = String</code>.</p>
<p>Let's modify our counter to remove the <code>bind</code> method on the <code>Label</code> within the <code>Counter</code> widet, and change the data associated type to <code>type Data = i32</code>. </p>
<h2 id="on-update"><a class="header" href="#on-update">On Update</a></h2>
<p>For actually updating the counter we'll use the <code>on_update</code> method provided by the <code>Widget</code> trait. Add the following code to the implementation of <code>Widget</code> for our <code>Counter</code> below the <code>on_update</code> method:</p>
<pre><code class="language-rs">fn on_update(&amp;mut self, state: &amp;mut State, entity: Entity, data: &amp;Self::Data) {
    self.label.set_text(state, &amp;data.to_string());
}
</code></pre>
<p>As with the <code>on_build</code> and <code>on_event</code> methods, the first three arguments are the same: a mutable reference to <code>Self</code> so internal widget data can be modified, and a mutable reference to <code>State</code> followed by an <code>Entity</code> id, for modifying style and layout properties as well as for sending events.</p>
<p>In this case we use the internal <code>label</code> field (which is the entity id of label) to set its text to the <code>data</code> value (converted from <code>i32</code> to a string) received when our counter widget is updated.</p>
<p>The last step is to add a call to <code>bind()</code> on the counter widget. Change the building of the counter widget to the following:</p>
<pre><code class="language-rs">Counter::default()
    .bind(CounterState::value, |value: &amp;i32| *value)
    .build(state, app_data, |builder| builder);
</code></pre>
<p>We pass the same lens as before to the value of the <code>CounterState</code> and the conversion closure converts the reference to the value into a copy.</p>
<p>So how does this work? </p>
<ol>
<li>Building the <code>Model</code> created a <code>Store</code>, which itself is a widget which contains the application data as well as a list of observer widgets (using entity ids).</li>
<li>The <code>bind</code> method sends an event to the store which registers the widget as an oberver.</li>
<li>Pressing a button sends an event up the tree to the store, which then mutates the data in response.</li>
<li>The store then calls the <code>on_update</code> method of all bound widgets, passing the new updated value.</li>
</ol>
<p>And we're done!</p>
<p>When we build and run our app now we get the same behaviour as before but our counter widget is now re-usable! We could now add this counter widget into any application, and we just need to bind it to a piece of data, using the conversion closure to convert that data in some way to an <code>i32</code>. The label would then display the value. The only other part required is to respond to <code>CounterEvent</code> messages emited by the counter's buttons.</p>
<p>The full code for this reactive counter can be found in the <code>/examples/counter_reactive.rs</code> file in the tuix repository and can be run with <code>cargo run --release --example counter_reactive</code>.</p>
<h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>This concludes the tuix 'quick' guide! If you made it this far, thanks for reading! The rest of this book attempts to cover the concepts shown in this guide in more detail, demonstrating what features are available and how they can be used to build complex user interfaces.</p>
<h2 id="coming-soon"><a class="header" href="#coming-soon">Coming Soon...</a></h2>
<p>Coming soon will be an 'advanced' guide in which a todo app will be created with more advanced features such as:</p>
<ul>
<li>Binding to lists of items</li>
<li>'Local' app data for syncing widgets in a sub-section of the tree</li>
<li>Animations (almost all style and layout properties are animatable)</li>
<li>Using more complex built-in widgets</li>
<li>Constructing more complex custom widgets</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-stack"><a class="header" href="#overview-stack">Overview (Stack)</a></h1>
<p>An overview of the layout system for working with stacks, in which child elements are positioned one after another.</p>
<ol>
<li>For stacking, a parent element can arrange its children into a vertical stack (<code>layout-type: column</code>) or a horizontal stack (<code>layout-type: row</code>).</li>
</ol>
<p><img src="layout/../images/layout_type3.png" alt="layout_type" /></p>
<ol start="2">
<li>A child element is positioned relative to its stack position (<code>position-type: parent-directed</code>), or relative to the top-left of its parent (<code>position-type: self-directed</code>).</li>
</ol>
<p><img src="layout/../images/position_type.png" alt="position_type" /></p>
<ol start="3">
<li>A child element can be positioned by adding space to the <code>left</code>, <code>right</code>, <code>top</code>, or <code>bottom</code> of an element.</li>
</ol>
<p><img src="layout/../images/spacing3.png" alt="spacing" /></p>
<ol start="4">
<li>Spacing can be expressed in pixels, percentage, stretch, or auto (see 8). Stretch causes the spacing to be flexible, occupying a proportion of the remaining free space. By default, spacing is set to auto.</li>
</ol>
<p><img src="layout/../images/position3.png" alt="spacing_units" /></p>
<ol start="5">
<li>The size of an element is determined by its <code>width</code> and <code>height</code>, which can also be expressed in pixels, percentage, stretch and auto. By default, size is set to stretch.</li>
</ol>
<p><img src="layout/../images/size3.png" alt="size_units" /></p>
<ol start="6">
<li>When size is set to auto, an element will 'hug' its children in that axis. This is also true for <code>min-width</code>/<code>min-height</code> (see 10).</li>
</ol>
<p><img src="layout/../images/auto_size.png" alt="auto_size" /></p>
<ol start="7">
<li>A parent can add space around its stacked children with <code>child-space</code>, or specified individually with <code>child-left</code>, <code>child-right</code>, <code>child-top</code>, <code>child-bottom</code>, or add space between its child elements with <code>child-between</code>.</li>
</ol>
<p><img src="layout/../images/child_spacing.png" alt="child_spacing" /></p>
<ol start="8">
<li>Child spacing applies to elements with spacing set to auto.</li>
</ol>
<p><img src="layout/../images/auto_spacing.png" alt="auto_spacing" /></p>
<ol start="9">
<li>Spacing set in pixels, percentage, or stretch overrides child spacing.</li>
</ol>
<p><img src="layout/../images/spacing_override.png" alt="spacing_override" /></p>
<ol start="10">
<li>All spacing and size properties have corresponding minimum and maximum constraint properties. For example, for <code>left</code> there is <code>min-left</code> and <code>max-left</code>. By default spacing and size minimums and maximums are set to auto. This will cause elements to <code>hug</code> their children if the size if flexible and goes below the minimum.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-grid"><a class="header" href="#overview-grid">Overview (Grid)</a></h1>
<p>An overview of the layout system for working with grids, in which child elements are positioned by row and column indices and span one or more rows and columns.</p>
<ol>
<li>A parent element can arrange its children into a grid (layout-type: grid).</li>
</ol>
<p><img src="layout/../images/grid.png" alt="layout_type" /></p>
<ol start="2">
<li>
<p>The rows and columns of a grid can be expressed in pixels, percentage, stretch, or auto.</p>
</li>
<li>
<p>A child element specifies its position with a row index and column index.</p>
</li>
<li>
<p>A child element specifies its size by spanning a number of rows and columns.</p>
</li>
<li></li>
</ol>
<!-- - **Axis** - refers to either horizontal (row) or vertical (column) directions. Left and right apply to the horizontal axis while top and bottom apply to the vertical axis.
- **Stack** - elements arranged within a parent one after another along an axis.

## Units

All spacing and size properties use the same `Units` enum, which has four variants:

1. **Pixels** - specifies a length pixels
2. **Percentage** - specifies a length as a percentage of the parent length in the same axis (e.g. percentage `left` would be a perctange of the parent width)
3. **Stretch** - specifies the length as a proportion of the free space available.
4. **Auto** - specifies that the length should be automatically determined. This variant has different behaviour depending on the property. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="child-properies-todo"><a class="header" href="#child-properies-todo">Child Properies (TODO)</a></h1>
<h2 id="position-type"><a class="header" href="#position-type">Position Type</a></h2>
<p>This determines how an element will be positioned within its parent relative to other child elements.</p>
<ul>
<li><strong>self-directed</strong> - The element determines its own position, relative to the top-left corner of the parent, and is not affected by other elements in a stack or grid.</li>
<li><strong>parent-directed</strong> (default) - The element is positioned by the parent into a stack or grid.</li>
</ul>
<h2 id="spacing"><a class="header" href="#spacing">Spacing</a></h2>
<p>There are four spacing properties that are used to specify the position an element within its parent:</p>
<ol>
<li>left - determines the space to the left of an element.</li>
<li>right - determines the space to the right of an element.</li>
<li>top - determines the space above an element.</li>
<li>bottom - determines the space below an element.</li>
</ol>
<p>The spacing properties behave somewhat like margins, adding space around an element. </p>
<h2 id="size"><a class="header" href="#size">Size</a></h2>
<p>The size of an element is determined by two properties:</p>
<ol>
<li>width - determines the width of an element.</li>
<li>height - determines the height of an element.</li>
</ol>
<p>Like with all spacing and size properties, the value can be expressed in pixels, percentage, stretch, and auto.</p>
<p><strong>Pixels</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parent-properies-todo"><a class="header" href="#parent-properies-todo">Parent Properies (TODO)</a></h1>
<h2 id="layout-type"><a class="header" href="#layout-type">Layout Type</a></h2>
<p><strong>Rust</strong></p>
<pre><code class="language-rs">enum LayoutType {
    Row,
    Column,
    Grid,
}
</code></pre>
<p><strong>Stylesheet:</strong></p>
<pre><code class="language-css">.container {
    layout-type: row | column | grid;
}
</code></pre>
<p>This determines how the child elements should be arranged in the parent.</p>
<ul>
<li><strong>Row</strong> - Child elements are arranged into a horizontal stack from left to right</li>
<li><strong>Column</strong> - Child elements are arranged into a vertical stack from top to bottom</li>
<li><strong>Grid</strong> - Child elements are arranged into a grid (link here)</li>
</ul>
<h2 id="child-space"><a class="header" href="#child-space">Child-Space</a></h2>
<p>This determines the spacing around the elements in a stack (does not apply to grid). </p>
<p>Each of the child spacing properties (see below), defined on the parent, acts to override the auto-spaced properties of the child elements. For example, the parent <code>child-left</code> property will override the <code>left</code> property of a child element if the <code>left</code> property is set to <code>Units::Auto</code>.</p>
<p>There are five child-space properties:</p>
<ol>
<li><strong>child-left</strong> - determines the space to the left of the stack. Applies to the <em>first</em> element in a horizontal stack and <em>all</em> elements in a vertical stack.</li>
<li><strong>child-right</strong> - determines the space to the right of the stack. Applies to the <em>last</em> element in a horizontal stack and <em>all</em> elements in a vertical stack.</li>
<li><strong>child-top</strong> - determines the space to the top of the stack. Applies to the <em>first</em> element in a vertical stack and <em>all</em> elements in a horizontal stack.</li>
<li><strong>child-bottom</strong> - determines the space to the top of the stack. Applies to the <em>last</em> element in a vertical stack and <em>all</em> elements in a horizontal stack.</li>
<li><strong>child-between</strong> - determines the space between elements on the main axis. Applies to all elements except the first and last and acts to override child <code>left</code> and <code>right</code> spacing.</li>
</ol>
<p>With these child spacing properties it is possible to do a number of alignment configurations:</p>
<h4 id="align-left"><a class="header" href="#align-left">Align Left</a></h4>
<pre><code class="language-css">.container {
    child-left: 0px;
    child-right: 1s;
}
</code></pre>
<h4 id="align-center"><a class="header" href="#align-center">Align Center</a></h4>
<pre><code class="language-css">.container {
    child-left: 1s;
    child-right: 1s;
}
</code></pre>
<h4 id="align-right"><a class="header" href="#align-right">Align Right</a></h4>
<pre><code class="language-css">.container {
    child-left: 1s;
    child-right: 0px;
}
</code></pre>
<h4 id="align-top"><a class="header" href="#align-top">Align Top</a></h4>
<pre><code class="language-css">.container {
    child-top: 0px;
    child-bottom: 1s;
}
</code></pre>
<h4 id="align-middle"><a class="header" href="#align-middle">Align Middle</a></h4>
<pre><code class="language-css">.container {
    child-top: 1s;
    child-bottom: 1s;
}
</code></pre>
<h4 id="align-bottom"><a class="header" href="#align-bottom">Align Bottom</a></h4>
<pre><code class="language-css">.container {
    child-top: 1s;
    child-bottom: 0px;
}
</code></pre>
<h4 id="space-between"><a class="header" href="#space-between">Space Between</a></h4>
<pre><code class="language-css">.container {
    child-between: 1s;
}
</code></pre>
<h4 id="space-evenly-row"><a class="header" href="#space-evenly-row">Space Evenly (Row)</a></h4>
<pre><code class="language-css">.container {
    child-left: 1s;
    child-right: 1s;
    child-between: 1s;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="size-1"><a class="header" href="#size-1">Size</a></h1>
<h2 id="width-and-height"><a class="header" href="#width-and-height">Width and Height</a></h2>
<p>The size of a widget is determined by its <code>width</code> and <code>height</code> properties, which both have the type of <code>Units</code> enum, which has four variants:</p>
<ol>
<li>Auto:
<ul>
<li>If the layout type is a column, then auto width will be the maximm child width and auto height will be the sum of the heights of its children.</li>
<li>If the layout type is a row, then auto width will be the sum of the widths of its children and auto height will be the maximum child height.</li>
</ul>
</li>
<li>Stretch: 
<ul>
<li>The width/height will stretch to fill some proportion of the remaining available space. The remaining available space is the space left after subtracting the width/height of non-stretch children.</li>
</ul>
</li>
<li>Percentage:
<ul>
<li>The width/height is a specified proportion of the parent width/height, unless overriden by min_/max_ width/height.</li>
</ul>
</li>
<li>Pixels:
<ul>
<li>The width/height is a specified number of pixels, unless overriden by min_/max_ width/height.</li>
</ul>
</li>
</ol>
<h2 id="size-constraints"><a class="header" href="#size-constraints">Size Constraints</a></h2>
<p>The width and height of a widget can be constrained by speifying a minimum and maxium using <code>min_width</code>, <code>max_width</code>, <code>min_height</code>, and <code>max_height</code>. These properties override the width and height properties and can be specified in <code>Units</code>:</p>
<ol>
<li>
<p>Auto:</p>
<ul>
<li>If the layout type is a column then the min_width </li>
</ul>
</li>
<li>
<p>Stretch:</p>
</li>
<li>
<p>Percentage:</p>
</li>
<li>
<p>Pixels:</p>
</li>
</ol>
<h1 id="position"><a class="header" href="#position">Position</a></h1>
<p>Child widgets added to a parent are arranged into either a vertical column, a horizontal row, or a grid and is determined by he <code>layout_type</code> property:</p>
<ol>
<li>Col:
<ul>
<li>Child widgets are arranged into a verical column.</li>
</ul>
</li>
<li>Row:
<ul>
<li>Child widgets are arranged into a horizontal row.</li>
</ul>
</li>
<li>Grid:
<ul>
<li>Child widgets are positioned by a row and column indices and their size is determined by row and column spans.</li>
</ul>
</li>
</ol>
<h2 id="position-type-1"><a class="header" href="#position-type-1">Position Type</a></h2>
<p>The <code>position_type</code> property specifies whether a widget should be affected by the position of the other child widgets.</p>
<ol>
<li>Parent-directed:
<ul>
<li>The widget is positioned by the parent relative to its usual position within a column, row, or grid.</li>
</ul>
</li>
<li>Self-directed:
<ul>
<li>The widget is positioned relative to the top-left corner of the parent and is not affected by sibling widgets.</li>
</ul>
</li>
</ol>
<h2 id="space"><a class="header" href="#space">Space</a></h2>
<p>The position of a widget can be modified by adding space to the <code>left</code>, <code>right</code>, <code>top</code>, and <code>bottom</code>, and is also specified in <code>Units</code>. All four properties can be set simultaneously with the <code>space</code> property.</p>
<ol>
<li>Auto:
<ul>
<li>The space is determined by the parents <code>child_space</code> properties. For example, an auto <code>left</code> is overriden by the parents <code>child_left</code> property.</li>
</ul>
</li>
<li>Stretch:
<ul>
<li>The space is a specified proportion of the available remaining space.</li>
</ul>
</li>
<li>Percentage:
<ul>
<li>The space is a specified proportion of the parent width/height, unless overridden by min/max constraints. </li>
</ul>
</li>
<li>Pixels:
<ul>
<li>The space is a specified number of pixels, unless overridden by min/max constraints.</li>
</ul>
</li>
</ol>
<h2 id="space-constraints"><a class="header" href="#space-constraints">Space Constraints</a></h2>
<p>The space properties can also be constrained with minimums and maximums, also using <code>Units</code>:</p>
<ol>
<li>Auto: </li>
<li>Stretch:</li>
<li>Percentage:</li>
<li>Pixels:</li>
</ol>
<h2 id="child-space-1"><a class="header" href="#child-space-1">Child Space</a></h2>
<p>While <code>space</code> is used to set the spacing of individual widgets, <code>child_space</code> is used to set the spacing of all child widgets in one go, as long that the child space properties are set to auto. Child space can be considered similar to padding and is also specified in <code>Units</code>:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="positioning-text-todo"><a class="header" href="#positioning-text-todo">Positioning Text (TODO)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout-properties"><a class="header" href="#layout-properties">Layout Properties</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Tuix has a built in system for generating and dispatching events to widgets in the hioerarchy. This is how widgets can respond to interaction, such as mouse clicks and keyboard presses, and also allows for widgets to communicate with each other.</p>
<p>Dispatched events are placed in a queue, and then the event manager sends the events to the relevant widgets which can respond by sending their own events. This process of receiving and sending events runs within a loop called the <em>Update Cycle</em> until there are no more events in the queue, at which point the application may redraw before waiting for the next OS event.</p>
<p>Unlike a game where the application is continuously updating and rerendering at a constant frame rate, a tuix application will only update when it receives an event from Operating System (except when an animation is playing). </p>
<h2 id="messages-1"><a class="header" href="#messages-1">Messages</a></h2>
<p>All events in tuix are wrapped in an<code>Event</code> type which contains meta data, such as the origin, target, and propagation type of the event, as well as the <strong>message</strong> which is a boxed dynamic <code>Message</code> object.</p>
<p>Any type which implments <code>Debug</code>, <code>Clone</code>, and <code>PartialEq</code> automatically implements the <code>Message</code> trait and can be used within an <code>Event</code>. For example:</p>
<pre><code class="language-rs">
// Can be used as a message
#[derive(Debug, Clone, PartialEq)]
pub enum CustomEvent {
    DoSomething,
    DoSomethingWithValue(String),
}

// Create a new event with a message of CustomEvent::DoSomething with a target of entity
let event = Event::new(CustomEvent::DoSomething).target(entity);
</code></pre>
<h2 id="event-propagation"><a class="header" href="#event-propagation">Event Propagation</a></h2>
<p>The propagation path determines which widgets will receive an event when it is dispatched by the event manager.</p>
<p>There are four types of event propagation:</p>
<ul>
<li><strong>DownUp</strong> - The event is sent from the root to the target and then back up to the root. This means that, unless the event is consumed, many widgets along the path, except for the target, will receive the event twice.</li>
<li><strong>Down</strong> - The event propagates down from the root to the target.</li>
<li><strong>Up</strong> - The event propagates up from the target to the root.</li>
<li><strong>Fall</strong> - The event propagates from the target down the branch to the last leaf widget.</li>
<li><strong>Direct</strong> - The event is sent directly to the target and no other widgets.</li>
</ul>
<h2 id="sending-events"><a class="header" href="#sending-events">Sending Events</a></h2>
<p>Sending or dispatching an event is the process of adding the event to the internal event queue within <code>State</code>.</p>
<p>The <code>insert_event()</code> method on <code>State</code> allows for an event to be added to the event queue. The origin, target, and propagation type should be specified on the event before adding it to the queue.</p>
<h3 id="convenience-functions"><a class="header" href="#convenience-functions">Convenience Functions</a></h3>
<p>Because the process of dispatching an event using the <code>insert_event()</code> method can be quite verbose, tuix provides a set of convenience methods for sending events with a particular target and propagation type and can be called directly on an entity, which then becomes the origin. </p>
<p>The following convenience functions take a message and generate the <code>Event</code> for you: </p>
<ul>
<li><code>entity.emit(message: impl Message)</code> - Sends an event with a message of <code>message</code>, with default propagation type (<code>DownUp</code>), and with <code>entity</code> as both the target and origin.</li>
<li><code>entity.emit_to(target: Entity)</code> - Sends an event with a message of <code>message</code>, with default propagation type (<code>DownUp</code>), with <code>target</code> as the target, and <code>entity</code> as the origin.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-propagation-1"><a class="header" href="#event-propagation-1">Event Propagation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-events-1"><a class="header" href="#handling-events-1">Handling Events</a></h1>
<p>Each update cycle, events in the queue will be dispatched to their target widgets. There are two primary methods for handling events sent to widgets:</p>
<ol>
<li>
<p><strong>Event Handlers</strong> allow for handling events in the same way for all intances of a particular widget type. For example, all button widgets should become 'active' when pressed.</p>
</li>
<li>
<p><strong>Callbacks</strong> allow for handling events on a per instance basis. For example, one button widget might trigger the window to close while another button might trigger the window to go fullscreen.</p>
</li>
</ol>
<h2 id="event-handlers"><a class="header" href="#event-handlers">Event Handlers</a></h2>
<p>To receive and respond to an event, a widget type must implement the <code>on_event()</code> method of the <code>Widget</code> trait.</p>
<p>Here is an example from the <code>Button</code> widget for responding to a left mouse button press on the widget:</p>
<pre><code class="language-rs">...
fn on_event(&amp;mut self, state: &amp;mut State, entity: Entity, event: &amp;mut Event) {
    
    if let Some(window_event) = event.message.downcast::&lt;WindowEvent&gt;() {
        match window_event {
            WindowEvent::MouseDown(button) if *button == MouseButton::Left =&gt; {
                // Code which runs when the left mouse button is pressed 
                // on the button widget (left out for brevity)
                ...
            }

            ...
        }
    }
}
...
</code></pre>
<p>Becuase the messages within events are boxed dynamic objects, the message must first be cast to the desired type with the <code>downcast()</code> method. Here we have specified the message type to cast to but Rust can actually infer this from the match statement that follows.</p>
<p>Once the message is the correct type, we can do things like match on the message type (if it's an enum) to respond to different message variants. In the above example the <code>WindowEvent</code> message contains a <code>MouseDown</code> variant which contains the mouse button which was pressed. A match guard is used to check if the mouse left button was pressed in which case it runs the contained code (left out for brevity).</p>
<p>Since the <code>on_event</code> method provides mutable access to the local properties of the widget, through <code>self</code>, and mutable access to the global state, through <code>state</code> using <code>entity</code>, there are a number of things that can be done within an event handler, including:</p>
<ul>
<li>Setting local widget properties through <code>self</code>.</li>
<li>Setting global widget properties through <code>state</code> using the widget <code>entity</code>.</li>
<li>Sending events.</li>
<li>Adding resources to State.</li>
</ul>
<h2 id="callbacks-1"><a class="header" href="#callbacks-1">Callbacks</a></h2>
<p>Callbacks are closures (functions), stored within a widget, which are triggered when a particular event is received. For example, the <code>Button</code> widget contains <code>on_press</code> and <code>on_release</code> callbacks which are triggered when the button is pressed (with the left nouse button) and released respectively.</p>
<p>Internally, this is acheived by handling the <code>WindowEvent::MouseDown</code> event within the event handler (<code>on_event</code> method) of the button which then calls the stored closures.</p>
<p>This example creates a new button with a callback which closes the window when pressed:</p>
<pre><code class="language-rs">Button::new()
    .on_press(|widget: &amp;mut Button, state: &amp;mut State, button: Entity| {
        button.emit(state, WindowEvent::CloseWindow);
    })
    .build(state, parent, |builder| builder);
</code></pre>
<p>For clarity, the closure argument types have been added. </p>
<p>A callback can have many forms but for the standard callbacks provided by the default widgets within tuix, the arguments to the closure mirror the arguments to the <code>on_event</code> method, allowing for the modification of local and global properties. </p>
<p>In the above example the first arguement is unused as no local properties are required. However, a widget such as the <code>Slider</code> contains the current value, which can be used within one of the callbacks of the slider, such as the <code>on_changing</code> callback:</p>
<pre><code class="language-rs">// Prints the current value of the slider while the slider value is changing,
// either by pressing the track or dragging the thumb along the track.
 Slider::new()
    .on_changing(|slider, state, entity| {
        entity.emit(WindowEvent::Debug(format!(&quot;Value: {}&quot;, slider.value)))
    })
    .build(state, parent, |builder| builder)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-events"><a class="header" href="#window-events">Window Events</a></h1>
<p>Events which are sent by the Operating System and are received by the appllication window are translated into a tuix <code>Event</code> with a <code>WindowEvent</code> message type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling"><a class="header" href="#styling">Styling</a></h1>
<p>Stlying lets us add properties to our widgets that change their visual appearance. Technically, layout propeties fall under styling as well, but for simplicity in learning the layout properties are detailed in a <a href="styling//layout/stack_overview.html">separate section of the book</a>.</p>
<h1 id="available-properties"><a class="header" href="#available-properties">Available Properties</a></h1>
<p>The table below shows the list of available style properties (layout properties are not shown for brevity). The property names are as they would appear in a css stylesheet. The property names in Rust are the same except dashes are replaced with underscores. For example, <code>background-color</code> in css becomes <code>background_color</code> in Rust.</p>
<table><thead><tr><th>Property</th><th>Value Type</th><th>Default Value</th><th>Animatable</th></tr></thead><tbody>
<tr><td>display</td><td>None | Flex</td><td>Flex</td><td>No</td></tr>
<tr><td>visibility</td><td>Visible | Invisible</td><td>Visible</td><td>No</td></tr>
<tr><td>opacity</td><td>f32 (0.0 - 1.0)</td><td>1.0</td><td>Yes</td></tr>
<tr><td>border-width</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-color</td><td>Color</td><td>Color::rgba(0,0,0,0)</td><td>Yes</td></tr>
<tr><td>border-radius</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-radius-top-left</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-radius-top-right</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-radius-bottom-left</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-radius-bottom-right</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>background-color</td><td>Color</td><td>Color::rgba(0,0,0,0)</td><td>Yes</td></tr>
<tr><td>background-gradient</td><td>LinearGradient</td><td></td><td>No</td></tr>
<tr><td>background-image</td><td>TODO</td><td></td><td>No</td></tr>
<tr><td>font</td><td>String</td><td></td><td>No</td></tr>
<tr><td>color</td><td>Color</td><td>Color::black()</td><td>Yes</td></tr>
<tr><td>font-size</td><td>f32</td><td>14.0</td><td>Yes</td></tr>
<tr><td>outer_shadow_h_offset</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>outer_shadow_v_offset</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>outer_shadow_blur</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>outer_shadow_color</td><td>Color</td><td>Color::rgba(0,0,0,0)</td><td>Yes</td></tr>
<tr><td>inner_shadow_h_offset</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>inner_shadow_v_offset</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>inner_shadow_blur</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>inner_shadow_color</td><td>Color</td><td>Color::rgba(0,0,0,0)</td><td>Yes</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-styling"><a class="header" href="#inline-styling">Inline Styling</a></h1>
<p>Inline properties refers to style and layout properties which are set on a per widget basis.</p>
<h2 id="setting-styles-on-entities"><a class="header" href="#setting-styles-on-entities">Setting styles on entities</a></h2>
<p>Style properties can be set on any widget by calling a property setter on its id. For example, to set the background color of a widget:</p>
<pre><code class="language-rs">entity.set_background_color(state, Color::blue());
</code></pre>
<p>where <code>entity</code> is the <code>Entity</code> id of the widget and <code>state</code> is a mutable reference to <code>State</code>. Property setters are available on the entity id thanks to the <code>PropSet</code> trait, which exposes setters for all of the style and layout properties.</p>
<h2 id="setting-styles-during-widget-building"><a class="header" href="#setting-styles-during-widget-building">Setting styles during widget building</a></h2>
<p>It is also possible to set the style properties of a widget when the widget is built using the <code>builder</code> argument of the supplied closure to the <code>build</code> method. For example, when building a <code>Button</code> instance we can set its background color like so:</p>
<pre><code class="language-rs">let button = Button::new().build(state, parent, |builder| 
    builder
        .set_background_color(Color::blue())
);
</code></pre>
<p>The name of the setter is identical to the one used on an entity id, except now a mutable reference to <code>State</code> is not required because there is one internal to the builder.</p>
<p>Note that the widget being acted upon when setting properties on the builder may not be the same widget as the one referred to by the returned entity id.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-styling"><a class="header" href="#shared-styling">Shared Styling</a></h1>
<p>Tuix provides a way to define styles which can be shared between several widgets. This can reduce both complexity and memory usage since only the style data is stored in memory.</p>
<p>Shared styles in tuix follow the same rules as css stylesheets, with selectors determining which widgets are affected by which style rules. This section covers how to define shared styles in tuix. For an overview of selectors, see the <a href="styling/">next section.</a>.</p>
<h2 id="style-rules-in-rust"><a class="header" href="#style-rules-in-rust">Style Rules in Rust</a></h2>
<p>TODO</p>
<h2 id="stylsheets"><a class="header" href="#stylsheets">Stylsheets</a></h2>
<p>An easier way to define shared styles is with the use of css. While tuix can parse a string or file containing css, not that many of the features of css are not supported, inlcuding the cascading which gives css a part of its name.</p>
<p>To add a css string to tuix, call <code>state.add_theme(css_string: &amp;str)</code>. Tuix will then parse the supplied string for style rules and add them to the application. The css string can be defined as a constant, for example:</p>
<pre><code class="language-rs">const STYLE: &amp;str = #r&quot;
    button {
        width: 100px;
        height: 30px;
        background-color: red;
    }
&quot;#
</code></pre>
<p>Or the css string can be included from a file using the <code>include_str!()</code> macro. For example:</p>
<pre><code class="language-rs">const STYLE: &amp;str = include_str!(&quot;path_to_css_file&quot;);
</code></pre>
<p>Then, to include the styles in the tuix application call:</p>
<pre><code class="language-rs">state.add_theme(STYLE);
</code></pre>
<h3 id="hot-reloading-of-stylesheets"><a class="header" href="#hot-reloading-of-stylesheets">Hot Reloading of Stylesheets</a></h3>
<p>Inlcuding the css string as a constant means that it cannot be updated while the program is running.</p>
<p>Tuix provides another method of including an external stylesheet within a .css file which can be modified and reloaded. To add a reloadable stylesheet call <code>state.add_stylesheet(path_to_css_file)</code>. This will load the contents of the file and parse any style rules. To reload the stylsheet while the application is running, press the F5 key.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style-properties"><a class="header" href="#style-properties">Style Properties</a></h1>
<p>The following sub-sections detail the styling properies currently available in tuix. This does <strong>not</strong> include the layout properties which are detailed <a href="styling/">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selectors"><a class="header" href="#selectors">Selectors</a></h1>
<p>Selectors determine which shared style rules affect which widgets and work in much the same way as css selectors. The main difference being that tuix does not support all forms of selector.</p>
<h2 id="element-selector"><a class="header" href="#element-selector">Element Selector</a></h2>
<p>Each type of widget can be given a unique name which can then be used to apply styles to all widgets of that type. For example, to set the background color of all <code>button</code> elements:</p>
<pre><code class="language-css">button {
    background-color: #555555;
}
</code></pre>
<p>The element name is typically set in the <code>on_build</code> method of a widget using the <code>.set_element(state: &amp;mut State, name: &amp;str)</code> method on the entity id. Unlike most other properties, a setter for the element name is not provided by the builder as the name is designed to be set for all widgets of the same type.</p>
<h2 id="class-selector"><a class="header" href="#class-selector">Class Selector</a></h2>
<p>Widgets can have multiple class names which can be selected using a dot followed by the name. For example, to set the background color of all widgets with a class name of <code>&quot;item&quot;</code>:</p>
<pre><code class="language-css">.item {
    background-color: #445566;
}
</code></pre>
<h1 id="pseudo-selectors"><a class="header" href="#pseudo-selectors">Pseudo-Selectors</a></h1>
<p>Shared styles can also contain pseudoselectors which select widgets based on a particular state that the widget is in. In tuix there are 8 pseudoselectors:</p>
<ol>
<li></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="display-properties"><a class="header" href="#display-properties">Display Properties</a></h1>
<p>There are three properties which affect whether a widget is displayed or not:</p>
<ol>
<li>display</li>
<li>visibility</li>
<li>opacity</li>
</ol>
<h2 id="display"><a class="header" href="#display">Display</a></h2>
<p>The <code>display</code> property determines whether or not a widget is included within both layout and rendering. The <code>display</code> property can be set to either <code>none</code> (<code>Display::None</code>), or <code>flex</code> (<code>Display::Flex</code>) which is the default. If the <code>display</code> property is set to <code>none</code> then the widget will not be included in layout and will not be rendered.</p>
<h2 id="visibility"><a class="header" href="#visibility">Visibility</a></h2>
<p>The <code>visibility</code> property affects only whether a widget will be included during rendering. Unlike <code>display</code>, the <code>visibility</code> of a widget does <em>not</em> affect layout. The <code>visibility</code> property can be set to either <code>visible</code> (<code>Visibility::Visible</code>), the default, or `</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background"><a class="header" href="#background">Background</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="border"><a class="header" href="#border">Border</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadows"><a class="header" href="#shadows">Shadows</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>While almost any desired gui behaviour can be acheived by sending events around, this can become hard to acheive when the application becomes more complex. For example, sending an event between two widgets that are far away from each other in the visual tree requires knowing the entity id of the target widget, which isn't always practical.</p>
<p>To solve these problems tuix has a built-in method for reactivity called binding. This section will cover bindings in detail but to begin with let's look at a basic example to see what exactly bindings achieve:</p>
<pre><code class="language-rs">use tuix::*;

#[derive(Lens)]
pub struct AppData {
    value: i32,
}

impl Model for AppData {}

fn main() {
    let app = Application::new(WindowDescription::new(), |state, window|{
        let app_data = AppData{value: 30}.build(state, window);

        Label::new(&quot;&quot;)
            .bind(AppData::value, |value| value.to_string())
            .build(state, app_data, |builder|
                builder
                    .set_width(Pixels(100.0))
                    .set_height(Pixels(100.0))
                    .set_space(Stretch(1.0))
                    .set_child_space(Stretch(1.0))
            );
    });

    app.run();    
}
</code></pre>
<p>This code can be found in <code>examples/binding/basic.rs</code> and can be run by calling <code>cargo run --example basic</code>.</p>
<p>The example above will show a window with a label in the center dispaying the number 30. This might not seem like much, but that value originates from a piece of state which has been placed into the tree and the label as aquired the value without any manual events needing to be sent, bu just calling the <code>bind()</code> method.</p>
<p>There's a lot going on here, so in the next sections we'll take a deep dive into each part of the above example and build on it as we go.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model"><a class="header" href="#model">Model</a></h1>
<p>For convenience, repeated here is the basic binding example from the previous section:</p>
<pre><code class="language-rs">use tuix::*;

#[derive(Lens)]
pub struct AppData {
    value: i32,
}

impl Model for AppData {}

fn main() {
    let app = Application::new(WindowDescription::new(), |state, window|{
        let app_data = AppData{value: 30}.build(state, window);

        Label::new(&quot;&quot;)
            .bind(AppData::value, |value| value.to_string())
            .build(state, app_data, |builder|
                builder
                    .set_width(Pixels(100.0))
                    .set_height(Pixels(100.0))
                    .set_space(Stretch(1.0))
                    .set_child_space(Stretch(1.0))
            );
    });

    app.run();    
}
</code></pre>
<p>The first part of this example is the creation of an <code>AppData</code> struct which contains a value with type <code>i32</code>. You've probably already spotted the <code>#[derive(Lens)]</code> macro but we'll save that for the next section.</p>
<p>Immediately after the declaration of this struct the trait <code>Model</code> is implmented for it. <code>Model</code> represents a piece of application state and allows us to embed it within the visual tree of widgets. However, a <code>Model</code> is not itself a <code>Widget</code>, and does not appear visually, but it can be used as a parent for a widget and can respond to events.</p>
<h2 id="mutating-the-model"><a class="header" href="#mutating-the-model">Mutating the Model</a></h2>
<p>In the basic example the value is hard-coded when an instance of the <code>AppData</code> is created, and there's currently no way to modify this value. This is where events come in. A <code>Model</code> can respond to events in the same way as a regular widget:</p>
<pre><code class="language-rs">#[derive(Debug, Clone, PartialEq)]
pub enum AppEvent {
    Increment,
    Decrement,
}

impl Model for AppData {
    fn on_event(&amp;mut self, state: &amp;mut State, entity: Entity, event: &amp;mut Event) {
        if let Some(app_event) = event.message.downcast() {
            match app_event {
                AppEvent::Increment =&gt; {
                    self.value += 1;
                    entity.emit(state, BindEvent::Update);
                }

                AppEvent::Decrement =&gt; {
                    self.value -= 1;
                    entity.emit(state, BindEvent::Update);
                }
            }
        }
    }
}
</code></pre>
<p>In the above code we've created an enum to represent some events (don't forget to derive <code>PartialEq</code>), and the implmentation of the <code>Model</code> trait for <code>AppData</code> has been modified to respond to these events, incrementing or decrementing the value.</p>
<p>Notice also the call to <code>entity.emit(state, BindEvent::Update)</code>. This event tells tuix that the model data has been modified and to update any widgets which are bound to it. Don't forget to call this when data has been modified!</p>
<p>With the above changes the model now has a way to be mutated. Now we just need to an <code>AppEvent</code> to the model. The easiest way to do this is to add some button and use the <code>on_press</code> callback. For example:</p>
<pre><code class="language-rs">Button::with_label(&quot;Increment&quot;)
    .on_press(|data, state, button|{
        button.emit(state, AppEvent::Increment);
    })
    .build(state, app_data, |builder|
        builder
            .set_width(Pixels(100.0))
            .set_height(Pixels(30.0))
            .set_background_color(Color::rgb(50,50,50))
            .set_space(Stretch(1.0))
            .set_child_space(Stretch(1.0))
    );

Button::with_label(&quot;Decrement&quot;)
    .on_press(|data, state, button|{
        button.emit(state, AppEvent::Decrement);
    })
    .build(state, app_data, |builder|
        builder
            .set_width(Pixels(100.0))
            .set_height(Pixels(30.0))
            .set_background_color(Color::rgb(50,50,50))
            .set_space(Stretch(1.0))
            .set_child_space(Stretch(1.0))
    );

</code></pre>
<p>Notice that the buttons have the <code>AppData</code> as the parent. As long as the <code>AppData</code> instance is an ancestor of both the buttons and the label then the reactivity will work. Events are sent up to the model to mutate it and updates are sent back down to the widgets which are bound to it.</p>
<p>The complete code can be found in <code>examples/binding/model.rs</code>. Pressing the increment or decrement buttons causes the value to increase or decrease by one and the label changes automatically to show the new value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lens"><a class="header" href="#lens">Lens</a></h1>
<p>In the previous sections we demonstrated binding a label to some data in a <code>Model</code> and used events to mutate the model and the text of the label updated automatically. This all seems to be possible simply by calling the <code>bind</code> method on a widget, so what exactly does this do, and what are its arguments?</p>
<p>For the basic example the binding looked like this:</p>
<pre><code class="language-rs">.bind(AppData::value, |value| value.to_string())
</code></pre>
<p>The first argument to this method is a <code>Lens</code>. You can think of a lens as a function which takes some data as input and returns a piece of that data as output, usually as references. For example, what we need for the basic example is a function which takes an <code>AppData</code> and returns the value, an <code>i32</code>.</p>
<p>But the lens in the <code>bind</code> method above doesn't look like a function. So what's going on here?</p>
<p>This is where the <code>#[derive(Lens)]</code> macro comes in. There is a function but it's within a trait called <code>Lens</code> which looks like this:</p>
<pre><code class="language-rs">pub trait Lens {
    type Source;
    type Target;

    fn view&lt;'a&gt;(&amp;self, data: &amp;'a Self::Source) -&gt; &amp;'a Self::Target;
}
</code></pre>
<p>The derive macro creates for us a zero-sized static type and then implments the <code>Lens</code> trait, which might look something like this:</p>
<pre><code class="language-rs">pub struct SomeGeneratedType;

impl Lens for SomeGeneratedType {
    type Source = AppData;
    type Target = i32;

    fn view&lt;'a&gt;(&amp;self, data: &amp;'a AppData) -&gt; &amp;'a i32 {
        &amp;data.value
    }
}
</code></pre>
<p>The other thing that the derive macro does is to create a static instance of the generated type, with the same name as the field (<code>value</code>), within a module called <code>AppData</code>. This is what allows us to use <code>AppData::value</code> to refer to the lens.</p>
<p>The second argument to the bind method is a converter closure which has as input the target type of the lens, in this case a reference to an <code>i32</code> value, and has as output the expected input of the label, in this case an owned <code>String</code>. Therefore, to convert between the two types we use the <code>.to_string()</code> method on the value.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
