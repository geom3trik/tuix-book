<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tuix Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Quick Start Guide</li><li class="chapter-item expanded "><a href="section_1_quick_start/chapter_1.html"><strong aria-hidden="true">1.</strong> Creating an Application</a></li><li class="chapter-item expanded "><a href="section_1_quick_start/chapter_2.html"><strong aria-hidden="true">2.</strong> Setting Window Properties</a></li><li class="chapter-item expanded "><a href="section_1_quick_start/chapter_3.html"><strong aria-hidden="true">3.</strong> Adding a Widget</a></li><li class="chapter-item expanded "><a href="section_1_quick_start/chapter_4.html"><strong aria-hidden="true">4.</strong> Composing Widgets</a></li><li class="chapter-item expanded "><a href="section_1_quick_start/chapter_5.html"><strong aria-hidden="true">5.</strong> Widget Layout</a></li><li class="chapter-item expanded "><a href="section_1_quick_start/chapter_6.html"><strong aria-hidden="true">6.</strong> Widget Styling</a></li><li class="chapter-item expanded "><a href="section_1_quick_start/chapter_7.html"><strong aria-hidden="true">7.</strong> Handling Events</a></li><li class="chapter-item expanded affix "><li class="part-title">Layout</li><li class="chapter-item expanded "><a href="section_2_layout/chapter_1.html"><strong aria-hidden="true">8.</strong> Overview (Stack)</a></li><li class="chapter-item expanded "><a href="section_2_layout/chapter_3.html"><strong aria-hidden="true">9.</strong> Child Properies</a></li><li class="chapter-item expanded "><a href="section_2_layout/chapter_4.html"><strong aria-hidden="true">10.</strong> Parent Properies</a></li><li class="chapter-item expanded "><a href="section_2_layout/chapter_2.html"><strong aria-hidden="true">11.</strong> Overview (Grid)</a></li><li class="chapter-item expanded "><a href="section_2_layout/chapter_5.html"><strong aria-hidden="true">12.</strong> Positioning Text</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Tuix Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="creating-a-tuix-application"><a class="header" href="#creating-a-tuix-application">Creating a Tuix Application</a></h1>
<p>The most basic tuix app looks like this:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let mut app = Application::new(|state, window| {});

    app.run();
}
</code></pre>
<p>Currently the closure passed to <code>new()</code> is empty, but this is where we will build our application.</p>
<p>Running this code with <code>cargo run</code> will produce an empty gray window with a width of 800 pixels and a height of 600 pixels. This isn't very interesting, so in the next section we'll cover changing window properties like size, title and icon.</p>
<p>For now let's go over the two arguments provided by the closure:</p>
<ul>
<li>
<p><code>state</code> - This is a mutable reference to the UI <code>State</code>, which represents the 'global' data of the widgets in a gui application, such as layout and style. A mutable reference to state is passed around when building widgets, handling events, and drawing widgets.</p>
</li>
<li>
<p><code>window</code> - This is a mutable reference to a <code>WindowBuilder</code>. With this we can modify the window properties.</p>
</li>
</ul>
<h1 id="setting-window-properties"><a class="header" href="#setting-window-properties">Setting Window Properties</a></h1>
<p>Window properties can be set using the <code>WindowBuilder</code>, which is the second argument of the closure passed to <code>Application::new()</code>.</p>
<pre><code class="language-rs">fn main() {
    let app = Application::new(|state, window|{
        window.set_title(&quot;Custom Title&quot;);
    })
}
</code></pre>
<p>Setting properties can also be chained together:</p>
<pre><code class="language-rs">fn main() {
    let app = Application::new(|state, window|{
        window.set_title(&quot;Custom Title&quot;).set_inner_size(400,300);
    })
}
</code></pre>
<h2 id="list-of-window-properties"><a class="header" href="#list-of-window-properties">List of Window Properties</a></h2>
<h4 id="window-title"><a class="header" href="#window-title">Window Title</a></h4>
<p>Sets the title of the window.</p>
<pre><code class="language-rs">set_title(title: &amp;str)
</code></pre>
<h4 id="window-inner-size"><a class="header" href="#window-inner-size">Window Inner Size</a></h4>
<p>Sets the inner size of the window.</p>
<pre><code class="language-rs">set_inner_size(width: u32, height: u32)
</code></pre>
<h4 id="window-inner-size-1"><a class="header" href="#window-inner-size-1">Window Inner Size</a></h4>
<p>Sets the minimum inner size of the window.</p>
<pre><code class="language-rs">set_min_inner_size(width: u32, height: u32)
</code></pre>
<h4 id="window-icon"><a class="header" href="#window-icon">Window Icon</a></h4>
<p>Sets the window icon.</p>
<pre><code class="language-rs">set_icon(&amp;mut self, icon: Vec&lt;u8&gt;, width: u32, height: u32)
</code></pre>
<p>The icon must first be loaded using the image crate. Example:</p>
<pre><code class="language-rs">let icon = image::open(&quot;resources/icons/calculator_dark-128.png&quot;).unwrap();

window.set_icon(icon.to_bytes(), icon.width(), icon.height());
</code></pre>
<h1 id="adding-a-widget"><a class="header" href="#adding-a-widget">Adding a Widget</a></h1>
<p>We can add a simple widget to our application like so:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let app = Application::new(|state, window| {
        
        window.set_title(&quot;Custom Title&quot;).set_inner_size(300,300);

        // Add an Element widget
        Element::new().build(state, window.entity(), |builder| builder);

    });

    app.run();
}
</code></pre>
<p>An <code>Element</code> widget is the simplest built-in widget that tuix has. It contains no data or event handling logic but can be styled like any other widget.</p>
<p>To add the element widget we first create a new instance with <code>Element::new()</code>, and then build the widget into the app with <code>.build(state, window.entity(), |builder| builder)</code>. </p>
<ul>
<li>
<p>The first argument,<code>state</code>, is a mutable reference to <code>State</code> from the application closure. </p>
</li>
<li>
<p>The second argument is the entity id of the parent widget, in this case the window widget, which we get by calling <code>window.entity()</code>. Each widget has an <code>Entity</code> id which can be used to get and set various widget properties stored in <code>State</code>.</p>
</li>
<li>
<p>The third argument is a closure which provides us with a builder we can use to set properties of the newly created widget.</p>
</li>
</ul>
<p>However, if you build and run this code you will still see an empty window.</p>
<p><img src="section_1_quick_start/../images/adding_widgets_01.png" alt="adding_widgets_01" /></p>
<p>This is because the <code>Element</code> widget has no built-in styling. To see the element, we can add a width, height, and background color using the builder:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let app = Application::new(|state, window| {
        
        window.set_title(&quot;Custom Title&quot;).set_inner_size(300,300);

        Element::new().build(state, window.entity(), |builder| 
            builder
                .set_width(Units::Pixels(100.0))
                .set_height(Units::Pixels(30.0))
                .set_background_color(Color::rgb(200,80,20))
        );

    });

    app.run();
}
</code></pre>
<p>This will produce a nice orange widget in the top left corner of the window with a width of 100 pixels and a height of 30 pixels. In the next section we will look at how to compose widgets together by adding a button to our element widget.</p>
<p><img src="section_1_quick_start/../images/adding_widgets_02.png" alt="adding_widgets_02" /></p>
<h1 id="composing-widgets"><a class="header" href="#composing-widgets">Composing Widgets</a></h1>
<p>To demonstrate the composition of widgets, let's add a <code>Button</code> widget to the <code>Element</code> widget we have from before:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let app = Application::new(|state, window| {
        
        window.set_title(&quot;Custom Title&quot;).set_inner_size(300,300);

        let container = Element::new().build(state, window.entity(), |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .set_background_color(Color::rgb(200,80,20))
        );

        // Add a Button widget as a child of the Element widget
        Button::new().build(state, container, |builder| 
            builder
                .set_width(Pixels(30.0))
                .set_height(Pixels(30.0))
                .set_background_color(Color::rgb(20,80,200))
        );

    });

    app.run();
}
</code></pre>
<p>Building the button widget works in the same way as the element widget. However, notice that the building of the element is now bound to a <code>container</code> variable. This is the <code>Entity</code> id of the element widget and is returned by the <code>.build(...)</code> function.</p>
<p>This id is then used to specify the element widget as the parent of the button widget in the button's <code>.build(...)</code> function. The button widget style properties are also different to the element widget to help distinguish them. </p>
<p>Running this code produces:</p>
<p><img src="section_1_quick_start/../images/composing_widgets_01.png" alt="adding_widgets_01" /></p>
<p>Composing widgets forms a tree, where each widget has a single parent and zero or more children. In tuix this tree is called the <code>Hierarchy</code>, and can be found in <code>State</code>. This hierarchy is used to propagate events as well as to draw the elements in the correct order.</p>
<p>We will cover the <code>Hierarchy</code> in more detail when we start to handle events and custom drawing a little later. In the next section we'll cover the basics of widget layout.</p>
<h1 id="widget-layout"><a class="header" href="#widget-layout">Widget Layout</a></h1>
<p>Tuix uses the layout properties defined on widgets to position them within the window and to determine their size.</p>
<p>To keep the quick start guide short, we will skip over the details of tuix's layout system. The layout system in tuix is quite comprehensive, and a more detailed guide can be found in the <a href="section_1_quick_start/">layout section</a>.</p>
<p>Now, so far we have defined a width and a height for our widgets so now we will position them. The following example positions the element in the center of the window:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let app = Application::new(|state, window| {
        
        window.set_title(&quot;Custom Title&quot;).set_inner_size(300,300);

        let container = Element::new().build(state, window.entity(), |builder| 
            builder
                .set_width(Units::Pixels(100.0))
                .set_height(Units::Pixels(30.0))

                // Add stretch spacing to all sides of the element
                .set_space_left(Stretch(1.0))
                .set_space_right(Stretch(1.0))
                .set_space_top(Stretch(1.0))
                .set_space_bottom(Stretch(1.0))

                .set_background_color(Color::rgb(200,80,20))
        );

        Button::new().build(state, container, |builder| 
            builder
                .set_width(Pixels(30.0))
                .set_height(Pixels(30.0))
                .set_background_color(Color::rgb(20,80,200))
        );

    });

    app.run();
}
</code></pre>
<p><img src="section_1_quick_start/../images/widget_layout_01.png" alt="widget_layout_01" /></p>
<p>We add space to each side of the element with units of <code>Stretch(1.0)</code>. Note, we could have also used <code>set_space()</code> to apply the same spacing to all sides. Looking at the horizontal axis, because both <code>left</code> and <code>right</code> are set to stretch, the layout algorithm splits the free space between them, resulting in equal space either side of the element. The same is done for the verical axis, resulting in a centered element.</p>
<p>Notice also that the button has moved, remaining in the top left corner of the element. This is because widgets are positioned relative to their parents.</p>
<h1 id="widget-styling"><a class="header" href="#widget-styling">Widget Styling</a></h1>
<p>As with layout, this quick start guide does not aim to cover all of the intricacies of styling and the properties available. A more comprehensive guide can be found in the <a href="section_1_quick_start/">styling section</a>.</p>
<h2 id="inline-and-shared-styling"><a class="header" href="#inline-and-shared-styling">Inline and Shared Styling</a></h2>
<p>So far we have defined our style properties directly on the widgets using the builder, also known as <em>inline</em> styling. Tuix also offers the ability to define style rules to allow <em>shared</em> styling between multiple widgets. The widgets affected by these shared style rules are determined by <em>selectors</em> which should be familiar to web developers using css and work in the same way.</p>
<p>The following code defines a style rule which acts on any widgets with a class name of <code>&quot;my_class&quot;</code>, and also gives this class name to our two widgets:</p>
<pre><code class="language-rs">use tuix::*;



fn main() {
    let app = Application::new(|state, window| {
        
        window.set_title(&quot;Custom Title&quot;).set_inner_size(300,300);

        // Create a shared style wich applies to all widgets with class name &quot;my_class&quot;
        let style_rule: StyleRule = StyleRule::new()
            .selector(Selector::new().class(&quot;my_class&quot;))
            .set_height(Pixels(30.0))
            .set_background_color(Color::rgb(80,200,20));

        // Add the shared style rule to state
        state.add_style_rule(style_rule);

        let container = Element::new().build(state, window.entity(), |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_space_left(Stretch(1.0))
                .set_space_right(Stretch(1.0))
                .set_space_top(Stretch(1.0))
                .set_space_bottom(Stretch(1.0))
                .set_background_color(Color::rgb(20,80,200))

                // Add a class name &quot;my_class&quot;
                .class(&quot;my_class&quot;)


        );

        Button::new().build(state, container, |builder| 
            builder
                .set_width(Pixels(30.0))

                // Add a class name &quot;my_class&quot;
                .class(&quot;my_class&quot;)
        );

    });

    app.run();
}
</code></pre>
<p>Note that the style rule has to be added to the app using <code>state.add_style_rule()</code>. Note also that <em>inline</em> properties override <em>shared</em> properties, so although both widgets are affected by the shared style, the button keeps its blue color as it comes from an inline style rule. The height property, on the other hand, is shared between the two widgets. Below is the output of this code:</p>
<p><img src="section_1_quick_start/../images/widget_styling_01.png" alt="widget_styling_01" /></p>
<h1 id="handling-events"><a class="header" href="#handling-events">Handling Events</a></h1>
<h1 id="overview-stack"><a class="header" href="#overview-stack">Overview (Stack)</a></h1>
<p>An overview of the layout system for working with stacks, in which child elements are positioned one after another.</p>
<ol>
<li>For stacking, a parent element arranges its children into a vertical stack (<code>layout-type: column</code>) or a horizontal stack (<code>layout-type: row</code>).</li>
</ol>
<p><img src="section_2_layout/../images/layout_type3.png" alt="layout_type" /></p>
<ol start="2">
<li>A child element can be positioned by adding space to the <code>left</code>, <code>right</code>, <code>top</code>, or <code>bottom</code> of an element.</li>
</ol>
<p><img src="section_2_layout/../images/spacing3.png" alt="spacing" /></p>
<ol start="3">
<li>A child element is positioned relative to its stack position (<code>position-type: parent-directed</code>), or relative to the top-left of its parent (<code>position-type: self-directed</code>).</li>
</ol>
<p><img src="section_2_layout/../images/position_type.png" alt="position_type" /></p>
<ol start="4">
<li>Spacing can be expressed in pixels, percentage, stretch, or auto (see 8). Stretch causes the spacing to be flexible, occupying a proportion of the remaining free space. By default, spacing is set to auto.</li>
</ol>
<p><img src="section_2_layout/../images/position3.png" alt="spacing_units" /></p>
<ol start="5">
<li>The size of an element is determined by its <code>width</code> and <code>height</code>, which can also be expressed in pixels, percentage, stretch and auto. By default, size is set to stretch.</li>
</ol>
<p><img src="section_2_layout/../images/size3.png" alt="size_units" /></p>
<ol start="6">
<li>When size is set to auto, an element will 'hug' its children in that axis. This is also true for <code>min-width</code>/<code>min-height</code> (see 10).</li>
</ol>
<p><img src="section_2_layout/../images/auto_size.png" alt="auto_size" /></p>
<ol start="7">
<li>A parent can add space around its stacked children with <code>child-space</code>, or specified individually with <code>child-left</code>, <code>child-right</code>, <code>child-top</code>, <code>child-bottom</code>, or add space between its child elements with <code>child-between</code>.</li>
</ol>
<p><img src="section_2_layout/../images/child_spacing.png" alt="child_spacing" /></p>
<ol start="8">
<li>Child spacing applies to elements with spacing set to auto.</li>
</ol>
<p><img src="section_2_layout/../images/auto_spacing.png" alt="auto_spacing" /></p>
<ol start="9">
<li>Spacing set in pixels, percentage, or stretch overrides child spacing.</li>
</ol>
<p><img src="section_2_layout/../images/spacing_override.png" alt="spacing_override" /></p>
<ol start="10">
<li>All spacing and size properties have corresponding minimum and maximum constraint properties. For example, for <code>left</code> there is <code>min-left</code> and <code>max-left</code>. By default spacing and size minimums and maximums are set to auto. This will cause elements to <code>hug</code> their children if the size if flexible and goes below the minimum.</li>
</ol>
<h1 id="child-properies-todo"><a class="header" href="#child-properies-todo">Child Properies (TODO)</a></h1>
<h2 id="position-type"><a class="header" href="#position-type">Position Type</a></h2>
<p>This determines how an element will be positioned within its parent relative to other child elements.</p>
<ul>
<li><strong>self-directed</strong> - The element determines its own position, relative to the top-left corner of the parent, and is not affected by other elements in a stack or grid.</li>
<li><strong>parent-directed</strong> (default) - The element is positioned by the parent into a stack or grid.</li>
</ul>
<h2 id="spacing"><a class="header" href="#spacing">Spacing</a></h2>
<p>There are four spacing properties that are used to specify the position an element within its parent:</p>
<ol>
<li>left - determines the space to the left of an element.</li>
<li>right - determines the space to the right of an element.</li>
<li>top - determines the space above an element.</li>
<li>bottom - determines the space below an element.</li>
</ol>
<p>The spacing properties behave somewhat like margins, adding space around an element. </p>
<h2 id="size"><a class="header" href="#size">Size</a></h2>
<p>The size of an element is determined by two properties:</p>
<ol>
<li>width - determines the width of an element.</li>
<li>height - determines the height of an element.</li>
</ol>
<p>Like with all spacing and size properties, the value can be expressed in pixels, percentage, stretch, and auto.</p>
<p><strong>Pixels</strong></p>
<h1 id="parent-properies-todo"><a class="header" href="#parent-properies-todo">Parent Properies (TODO)</a></h1>
<h2 id="layout-type"><a class="header" href="#layout-type">Layout Type</a></h2>
<p><strong>Rust</strong></p>
<pre><code class="language-rs">enum LayoutType {
    Row,
    Column,
    Grid,
}
</code></pre>
<p><strong>Stylesheet:</strong></p>
<pre><code class="language-css">.container {
    layout-type: row | column | grid;
}
</code></pre>
<p>This determines how the child elements should be arranged in the parent.</p>
<ul>
<li><strong>Row</strong> - Child elements are arranged into a horizontal stack from left to right</li>
<li><strong>Column</strong> - Child elements are arranged into a vertical stack from top to bottom</li>
<li><strong>Grid</strong> - Child elements are arranged into a grid (link here)</li>
</ul>
<h2 id="child-space"><a class="header" href="#child-space">Child-Space</a></h2>
<p>This determines the spacing around the elements in a stack (does not apply to grid). </p>
<p>Each of the child spacing properties (see below), defined on the parent, acts to override the auto-spaced properties of the child elements. For example, the parent <code>child-left</code> property will override the <code>left</code> property of a child element if the <code>left</code> property is set to <code>Units::Auto</code>.</p>
<p>There are five child-space properties:</p>
<ol>
<li><strong>child-left</strong> - determines the space to the left of the stack. Applies to the <em>first</em> element in a horizontal stack and <em>all</em> elements in a vertical stack.</li>
<li><strong>child-right</strong> - determines the space to the right of the stack. Applies to the <em>last</em> element in a horizontal stack and <em>all</em> elements in a vertical stack.</li>
<li><strong>child-top</strong> - determines the space to the top of the stack. Applies to the <em>first</em> element in a vertical stack and <em>all</em> elements in a horizontal stack.</li>
<li><strong>child-bottom</strong> - determines the space to the top of the stack. Applies to the <em>last</em> element in a vertical stack and <em>all</em> elements in a horizontal stack.</li>
<li><strong>child-between</strong> - determines the space between elements on the main axis. Applies to all elements except the first and last and acts to override child <code>left</code> and <code>right</code> spacing.</li>
</ol>
<p>With these child spacing properties it is possible to do a number of alignment configurations:</p>
<h4 id="align-left"><a class="header" href="#align-left">Align Left</a></h4>
<pre><code class="language-css">.container {
    child-left: 0px;
    child-right: 1s;
}
</code></pre>
<h4 id="align-center"><a class="header" href="#align-center">Align Center</a></h4>
<pre><code class="language-css">.container {
    child-left: 1s;
    child-right: 1s;
}
</code></pre>
<h4 id="align-right"><a class="header" href="#align-right">Align Right</a></h4>
<pre><code class="language-css">.container {
    child-left: 1s;
    child-right: 0px;
}
</code></pre>
<h4 id="align-top"><a class="header" href="#align-top">Align Top</a></h4>
<pre><code class="language-css">.container {
    child-top: 0px;
    child-bottom: 1s;
}
</code></pre>
<h4 id="align-middle"><a class="header" href="#align-middle">Align Middle</a></h4>
<pre><code class="language-css">.container {
    child-top: 1s;
    child-bottom: 1s;
}
</code></pre>
<h4 id="align-bottom"><a class="header" href="#align-bottom">Align Bottom</a></h4>
<pre><code class="language-css">.container {
    child-top: 1s;
    child-bottom: 0px;
}
</code></pre>
<h4 id="space-between"><a class="header" href="#space-between">Space Between</a></h4>
<pre><code class="language-css">.container {
    child-between: 1s;
}
</code></pre>
<h4 id="space-evenly-row"><a class="header" href="#space-evenly-row">Space Evenly (Row)</a></h4>
<pre><code class="language-css">.container {
    child-left: 1s;
    child-right: 1s;
    child-between: 1s;
}
</code></pre>
<h1 id="overview-grid"><a class="header" href="#overview-grid">Overview (Grid)</a></h1>
<!-- - **Axis** - refers to either horizontal (row) or vertical (column) directions. Left and right apply to the horizontal axis while top and bottom apply to the vertical axis.
- **Stack** - elements arranged within a parent one after another along an axis.

## Units

All spacing and size properties use the same `Units` enum, which has four variants:

1. **Pixels** - specifies a length pixels
2. **Percentage** - specifies a length as a percentage of the parent length in the same axis (e.g. percentage `left` would be a perctange of the parent width)
3. **Stretch** - specifies the length as a proportion of the free space available.
4. **Auto** - specifies that the length should be automatically determined. This variant has different behaviour depending on the property. -->
<h1 id="positioning-text-todo"><a class="header" href="#positioning-text-todo">Positioning Text (TODO)</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
