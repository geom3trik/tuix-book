<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tuix Guide</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Quick Start Guide</li><li class="chapter-item expanded "><a href="quick_start/creating_an_application.html"><strong aria-hidden="true">1.</strong> Creating an Application</a></li><li class="chapter-item expanded "><a href="quick_start/setting_window_properties.html"><strong aria-hidden="true">2.</strong> Setting Window Properties</a></li><li class="chapter-item expanded "><a href="quick_start/adding_a_widget.html"><strong aria-hidden="true">3.</strong> Adding a Widget</a></li><li class="chapter-item expanded "><a href="quick_start/composing_widgets.html"><strong aria-hidden="true">4.</strong> Composing Widgets</a></li><li class="chapter-item expanded "><a href="quick_start/widget_layout.html"><strong aria-hidden="true">5.</strong> Widget Layout</a></li><li class="chapter-item expanded "><a href="quick_start/widget_styling.html"><strong aria-hidden="true">6.</strong> Widget Styling</a></li><li class="chapter-item expanded "><a href="quick_start/handling_events.html"><strong aria-hidden="true">7.</strong> Handling Events</a></li><li class="chapter-item expanded affix "><li class="part-title">Layout</li><li class="chapter-item expanded "><a href="layout/stack_overview.html"><strong aria-hidden="true">8.</strong> Overview (Stack)</a></li><li class="chapter-item expanded "><a href="layout/child_properties.html"><strong aria-hidden="true">9.</strong> Child Properies</a></li><li class="chapter-item expanded "><a href="layout/parent_properties.html"><strong aria-hidden="true">10.</strong> Parent Properies</a></li><li class="chapter-item expanded "><a href="layout/grid_overview.html"><strong aria-hidden="true">11.</strong> Overview (Grid)</a></li><li class="chapter-item expanded "><a href="layout/positioning_text.html"><strong aria-hidden="true">12.</strong> Positioning Text</a></li><li class="chapter-item expanded affix "><li class="part-title">Events</li><li class="chapter-item expanded "><a href="events/chapter_1.html"><strong aria-hidden="true">13.</strong> Overview</a></li><li class="chapter-item expanded "><a href="events/events_and_messages.html"><strong aria-hidden="true">14.</strong> Events and Messages</a></li><li class="chapter-item expanded "><a href="events/event_propagation.html"><strong aria-hidden="true">15.</strong> Event Propagation</a></li><li class="chapter-item expanded "><a href="events/handling_events.html"><strong aria-hidden="true">16.</strong> Handling Events</a></li><li class="chapter-item expanded "><a href="events/window_events.html"><strong aria-hidden="true">17.</strong> Window Events</a></li><li class="chapter-item expanded affix "><li class="part-title">Styling</li><li class="chapter-item expanded "><a href="styling/overview.html"><strong aria-hidden="true">18.</strong> Overview</a></li><li class="chapter-item expanded "><a href="styling/inline_styling.html"><strong aria-hidden="true">19.</strong> Inline Styling</a></li><li class="chapter-item expanded "><a href="styling/shared_styling.html"><strong aria-hidden="true">20.</strong> Shared Styling</a></li><li class="chapter-item expanded "><a href="styling/display.html"><strong aria-hidden="true">21.</strong> Display</a></li><li class="chapter-item expanded "><a href="styling/background.html"><strong aria-hidden="true">22.</strong> Background</a></li><li class="chapter-item expanded "><a href="styling/border.html"><strong aria-hidden="true">23.</strong> Border</a></li><li class="chapter-item expanded "><a href="styling/shadows.html"><strong aria-hidden="true">24.</strong> Shadows</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tuix Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tuix"><a class="header" href="#tuix">Tuix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-tuix-application"><a class="header" href="#creating-a-tuix-application">Creating a Tuix Application</a></h1>
<p>The most basic tuix app looks like this:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let mut app = Application::new(WindowDescription::new(), |state, window| {});

    app.run();
}
</code></pre>
<p>The first argument passed to <code>Application::new()</code> is a new instance of a <code>WindowDescription</code>. This allows us to set the initial properties of the root window created for us by tuix. </p>
<p>The second argument passed to the new method is a closure which provides us with two variables:</p>
<ol>
<li>
<p><code>state</code> - This is a mutable reference to the UI <code>State</code>, which represents the 'global' data of the widgets in a gui application, such as layout and style properties. A mutable reference to state is passed around when building widgets, handling events, and drawing widgets.</p>
</li>
<li>
<p><code>window</code> - This is an <code>Entity</code> id to the window widget created for us by tuix. Every widget has an entity id which is used with state to modify UI properties.</p>
</li>
</ol>
<p>Running this code with <code>cargo run</code> will produce an empty gray window with a width of 800 pixels and a height of 600 pixels. This isn't very interesting, so in the next section we'll cover changing window properties like size, title, and icon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-window-properties"><a class="header" href="#setting-window-properties">Setting Window Properties</a></h1>
<p>Window properties can be set using the <code>WindowDescription</code>, which is the second argument of the closure passed to <code>Application::new()</code>.</p>
<pre><code class="language-rs">fn main() {
    let app = Application::new(
        WindowDescription::new().with_title(&quot;Custom Title&quot;), 
        |state, window|{}
    );
}
</code></pre>
<p>Using the builder pattern, setting window properties can be chained together:</p>
<pre><code class="language-rs">fn main() {
    let app = Application::new(
        WindowDescription::new().with_title(&quot;Custom Title&quot;).with_inner_size(300, 300),
        |state, window|{}
    );
}
</code></pre>
<p>To see the full list of window properties that can be set, see the docs page on <code>WindowDescription</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-widget"><a class="header" href="#adding-a-widget">Adding a Widget</a></h1>
<p>We can add a simple widget to our application like so:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Custom Title&quot;)
        .with_inner_size(300, 300);
    let app = Application::new(|state, window| {
            
            // Add an Element widget
            Element::new().build(state, window.entity(), |builder| builder);
        },
    );

    app.run();
}

</code></pre>
<p>An <code>Element</code> widget is the simplest built-in widget that tuix has. It contains no data or event handling logic but can be styled like any other widget.</p>
<p>To add the element widget we first create a new instance with <code>Element::new()</code>, and then build the widget into the app with <code>.build(state, window.entity(), |builder| builder)</code>. </p>
<ul>
<li>
<p>The first argument,<code>state</code>, is a mutable reference to <code>State</code> from the application closure. </p>
</li>
<li>
<p>The second argument is the entity id of the parent widget, in this case the window widget, which we get by calling <code>window.entity()</code>. Each widget has an <code>Entity</code> id which can be used to get and set various widget properties stored in <code>State</code>.</p>
</li>
<li>
<p>The third argument is a closure which provides us with a builder we can use to set properties of the newly created widget.</p>
</li>
</ul>
<p>However, if you build and run this code you will still see an empty window.</p>
<p><img src="quick_start/../images/adding_widgets_01.png" alt="adding_widgets_01" /></p>
<p>This is because the <code>Element</code> widget has no built-in styling. To see the element, we can add a width, height, and background color using the builder:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Custom Title&quot;)
        .with_inner_size(300, 300);
    let app = Application::new(window_description, |state, window| {
            
            Element::new().build(state, window.entity(), |builder| {
                builder
                    .set_width(Pixels(100.0))
                    .set_height(Pixels(30.0))
                    .set_background_color(Color::rgb(200, 80, 20))
            });
        
        },
    );

    app.run();
}
</code></pre>
<p>This will produce a nice orange widget in the top left corner of the window with a width of 100 pixels and a height of 30 pixels. In the next section we will look at how to compose widgets together by adding a button to our element widget.</p>
<p><img src="quick_start/../images/adding_widgets_02.png" alt="adding_widgets_02" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composing-widgets"><a class="header" href="#composing-widgets">Composing Widgets</a></h1>
<p>To demonstrate the composition of widgets, let's add a <code>Button</code> widget to the <code>Element</code> widget we have from before:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Custom Title&quot;)
        .with_inner_size(300, 300);
    let app = Application::new(window_description, |state, window| {
        
        let container = Element::new().build(state, window.entity(), |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_height(Pixels(30.0))
                .set_background_color(Color::rgb(200,80,20))
        );

        // Add a Button widget as a child of the Element widget
        Button::new().build(state, container, |builder| 
            builder
                .set_width(Pixels(30.0))
                .set_height(Pixels(30.0))
                .set_background_color(Color::rgb(20,80,200))
        );

    });

    app.run();
}
</code></pre>
<p>Building the button widget works in the same way as the element widget. However, notice that the building of the element is now bound to a <code>container</code> variable. This is the <code>Entity</code> id of the element widget and is returned by the <code>.build(...)</code> function.</p>
<p>This id is then used to specify the element widget as the parent of the button widget in the button's <code>.build(...)</code> function. The button widget style properties are also different to the element widget to help distinguish them. </p>
<p>Running this code produces:</p>
<p><img src="quick_start/../images/composing_widgets_01.png" alt="adding_widgets_01" /></p>
<p>Composing widgets forms a tree, where each widget has a single parent and zero or more children. In tuix this tree is called the <code>Hierarchy</code>, and can be found in <code>State</code>. This hierarchy is used to propagate events as well as to draw the elements in the correct order.</p>
<p>We will cover the <code>Hierarchy</code> in more detail when we start to handle events and custom drawing a little later. In the next section we'll cover the basics of widget layout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-layout"><a class="header" href="#widget-layout">Widget Layout</a></h1>
<p>Tuix uses the layout properties defined on widgets to position them within the window and to determine their size.</p>
<p>To keep the quick start guide short, we will skip over the details of tuix's layout system. The layout system in tuix is quite comprehensive, and a more detailed guide can be found in the <a href="https://geom3trik.github.io/tuix-book/section_2_layout/chapter_1.html">layout section</a>.</p>
<p>Now, so far we have defined a width and a height for our widgets so now we will position them. The following example positions the element in the center of the window:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {

    let window_description = WindowDescription::new()
            .with_title(&quot;Custom Title&quot;)
            .with_inner_size(300, 300);

    let app = Application::new(window_description, |state, window| {

        let container = Element::new().build(state, window.entity(), |builder| 
            builder
                .set_width(Units::Pixels(100.0))
                .set_height(Units::Pixels(30.0))

                // Add stretch spacing to all sides of the element
                .set_space_left(Stretch(1.0))
                .set_space_right(Stretch(1.0))
                .set_space_top(Stretch(1.0))
                .set_space_bottom(Stretch(1.0))

                .set_background_color(Color::rgb(200,80,20))
        );

        Button::new().build(state, container, |builder| 
            builder
                .set_width(Pixels(30.0))
                .set_height(Pixels(30.0))
                .set_background_color(Color::rgb(20,80,200))
        );

    });

    app.run();
}
</code></pre>
<p><img src="quick_start/../images/widget_layout_01.png" alt="widget_layout_01" /></p>
<p>We add space to each side of the element with units of <code>Stretch(1.0)</code>. Note, we could have also used <code>set_space()</code> to apply the same spacing to all sides. Looking at the horizontal axis, because both <code>left</code> and <code>right</code> are set to stretch, the layout algorithm splits the free space between them, resulting in equal space either side of the element. The same is done for the verical axis, resulting in a centered element.</p>
<p>Notice also that the button has moved, remaining in the top left corner of the element. This is because widgets are positioned relative to their parents.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-styling"><a class="header" href="#widget-styling">Widget Styling</a></h1>
<p>As with layout, this quick start guide does not aim to cover all of the intricacies of styling and the properties available. A more comprehensive guide can be found in the <a href="quick_start/">styling section</a>.</p>
<h2 id="inline-and-shared-styling"><a class="header" href="#inline-and-shared-styling">Inline and Shared Styling</a></h2>
<p>So far we have defined our style properties directly on the widgets using the builder, also known as <em>inline</em> styling. Tuix also offers the ability to define style rules to allow <em>shared</em> styling between multiple widgets. The widgets affected by these shared style rules are determined by <em>selectors</em> which should be familiar to web developers using css and work in the same way.</p>
<p>The following code defines a style rule which acts on any widgets with a class name of <code>&quot;my_class&quot;</code>, and also gives this class name to our two widgets:</p>
<pre><code class="language-rs">use tuix::*;

fn main() {
    let window_description = WindowDescription::new()
        .with_title(&quot;Custom Title&quot;)
        .with_inner_size(300, 300);

    let app = Application::new(window_description, |state, window| {
    
        // Create a shared style wich applies to all widgets with class name &quot;my_class&quot;
        let style_rule: StyleRule = StyleRule::new()
            .selector(Selector::new().class(&quot;my_class&quot;))
            .set_height(Pixels(30.0))
            .set_background_color(Color::rgb(80,200,20));

        // Add the shared style rule to state
        state.add_style_rule(style_rule);

        let container = Element::new().build(state, window.entity(), |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_space_left(Stretch(1.0))
                .set_space_right(Stretch(1.0))
                .set_space_top(Stretch(1.0))
                .set_space_bottom(Stretch(1.0))
                .set_background_color(Color::rgb(20,80,200))

                // Add a class name &quot;my_class&quot;
                .class(&quot;my_class&quot;)
        );

        Button::new().build(state, container, |builder| 
            builder
                .set_width(Pixels(30.0))

                // Add a class name &quot;my_class&quot;
                .class(&quot;my_class&quot;)
        );

    });

    app.run();
}
</code></pre>
<p>Note that the style rule has to be added to the app using <code>state.add_style_rule()</code>. Note also that <em>inline</em> properties override <em>shared</em> properties, so although both widgets are affected by the shared style, the button keeps its blue color as it comes from an inline style rule. The height property, on the other hand, is shared between the two widgets. Below is the output of this code:</p>
<p><img src="quick_start/../images/widget_styling_01.png" alt="widget_styling_01" /></p>
<h2 id="stylesheets"><a class="header" href="#stylesheets">Stylesheets</a></h2>
<p>Tuix also offers the ability to define styles in separate stylesheet files with .css extensions. However, although some of the style properties available in tuix share the same name as css properties, in general the available style properties are different.</p>
<p>We can produce the same shared style as before with the following code in a separate 'theme.css' file:</p>
<pre><code class="language-css">.my_class {
    height: 30px;
    background-color: #50c814;
}
</code></pre>
<p>This file can then be included in the binary with the <code>include_str!</code> macro and then added to the application with <code>state.add_theme()</code> like so:</p>
<pre><code class="language-rs">use tuix::*;

const THEME: &amp;str = include_str!(&quot;path_to_stylesheet/theme.css&quot;);

fn main() {
    let window_description = WindowDescription::new().with_title(&quot;Custom Title&quot;).set_inner_size(300,300);
    let app = Application::new(window_description, |state, window| {
        
        // Add external stylehseet to the application
        state.add_theme(THEME);

        let container = Element::new().build(state, window.entity(), |builder| 
            builder
                .set_width(Pixels(100.0))
                .set_space_left(Stretch(1.0))
                .set_space_right(Stretch(1.0))
                .set_space_top(Stretch(1.0))
                .set_space_bottom(Stretch(1.0))
                .set_background_color(Color::rgb(20,80,200))

                // Add a class name &quot;my_class&quot;
                .class(&quot;my_class&quot;)


        );

        Button::new().build(state, container, |builder| 
            builder
                .set_width(Pixels(30.0))

                // Add a class name &quot;my_class&quot;
                .class(&quot;my_class&quot;)
        );

    });

    app.run();
}
</code></pre>
<p>Alternatively, <code>state.add_stylesheet()</code> can be used to add a stylesheet dynamically by specifying the path to the css file. This allows for hot reloading of the stylesheet using the F5 key, however, the css file must be shipped with the executable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>So far we've seen how to add, position, and style widgets. However, this isn't very useful without the ability for widgets to communicate with each other.</p>
<p>This is where events come in. Inside of <code>State</code> there is a queue which events can be pushed to, and each update cycle the events are sent to the relevant widgets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-stack"><a class="header" href="#overview-stack">Overview (Stack)</a></h1>
<p>An overview of the layout system for working with stacks, in which child elements are positioned one after another.</p>
<ol>
<li>For stacking, a parent element can arrange its children into a vertical stack (<code>layout-type: column</code>) or a horizontal stack (<code>layout-type: row</code>).</li>
</ol>
<p><img src="layout/../images/layout_type3.png" alt="layout_type" /></p>
<ol start="2">
<li>A child element is positioned relative to its stack position (<code>position-type: parent-directed</code>), or relative to the top-left of its parent (<code>position-type: self-directed</code>).</li>
</ol>
<p><img src="layout/../images/position_type.png" alt="position_type" /></p>
<ol start="3">
<li>A child element can be positioned by adding space to the <code>left</code>, <code>right</code>, <code>top</code>, or <code>bottom</code> of an element.</li>
</ol>
<p><img src="layout/../images/spacing3.png" alt="spacing" /></p>
<ol start="4">
<li>Spacing can be expressed in pixels, percentage, stretch, or auto (see 8). Stretch causes the spacing to be flexible, occupying a proportion of the remaining free space. By default, spacing is set to auto.</li>
</ol>
<p><img src="layout/../images/position3.png" alt="spacing_units" /></p>
<ol start="5">
<li>The size of an element is determined by its <code>width</code> and <code>height</code>, which can also be expressed in pixels, percentage, stretch and auto. By default, size is set to stretch.</li>
</ol>
<p><img src="layout/../images/size3.png" alt="size_units" /></p>
<ol start="6">
<li>When size is set to auto, an element will 'hug' its children in that axis. This is also true for <code>min-width</code>/<code>min-height</code> (see 10).</li>
</ol>
<p><img src="layout/../images/auto_size.png" alt="auto_size" /></p>
<ol start="7">
<li>A parent can add space around its stacked children with <code>child-space</code>, or specified individually with <code>child-left</code>, <code>child-right</code>, <code>child-top</code>, <code>child-bottom</code>, or add space between its child elements with <code>child-between</code>.</li>
</ol>
<p><img src="layout/../images/child_spacing.png" alt="child_spacing" /></p>
<ol start="8">
<li>Child spacing applies to elements with spacing set to auto.</li>
</ol>
<p><img src="layout/../images/auto_spacing.png" alt="auto_spacing" /></p>
<ol start="9">
<li>Spacing set in pixels, percentage, or stretch overrides child spacing.</li>
</ol>
<p><img src="layout/../images/spacing_override.png" alt="spacing_override" /></p>
<ol start="10">
<li>All spacing and size properties have corresponding minimum and maximum constraint properties. For example, for <code>left</code> there is <code>min-left</code> and <code>max-left</code>. By default spacing and size minimums and maximums are set to auto. This will cause elements to <code>hug</code> their children if the size if flexible and goes below the minimum.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-grid"><a class="header" href="#overview-grid">Overview (Grid)</a></h1>
<p>An overview of the layout system for working with grids, in which child elements are positioned by row and column indices and span one or more rows and columns.</p>
<ol>
<li>A parent element can arrange its children into a grid (layout-type: grid).</li>
</ol>
<p><img src="layout/../images/grid.png" alt="layout_type" /></p>
<ol start="2">
<li>
<p>The rows and columns of a grid can be expressed in pixels, percentage, stretch, or auto.</p>
</li>
<li>
<p>A child element specifies its position with a row index and column index.</p>
</li>
<li>
<p>A child element specifies its size by spanning a number of rows and columns.</p>
</li>
<li></li>
</ol>
<!-- - **Axis** - refers to either horizontal (row) or vertical (column) directions. Left and right apply to the horizontal axis while top and bottom apply to the vertical axis.
- **Stack** - elements arranged within a parent one after another along an axis.

## Units

All spacing and size properties use the same `Units` enum, which has four variants:

1. **Pixels** - specifies a length pixels
2. **Percentage** - specifies a length as a percentage of the parent length in the same axis (e.g. percentage `left` would be a perctange of the parent width)
3. **Stretch** - specifies the length as a proportion of the free space available.
4. **Auto** - specifies that the length should be automatically determined. This variant has different behaviour depending on the property. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="child-properies-todo"><a class="header" href="#child-properies-todo">Child Properies (TODO)</a></h1>
<h2 id="position-type"><a class="header" href="#position-type">Position Type</a></h2>
<p>This determines how an element will be positioned within its parent relative to other child elements.</p>
<ul>
<li><strong>self-directed</strong> - The element determines its own position, relative to the top-left corner of the parent, and is not affected by other elements in a stack or grid.</li>
<li><strong>parent-directed</strong> (default) - The element is positioned by the parent into a stack or grid.</li>
</ul>
<h2 id="spacing"><a class="header" href="#spacing">Spacing</a></h2>
<p>There are four spacing properties that are used to specify the position an element within its parent:</p>
<ol>
<li>left - determines the space to the left of an element.</li>
<li>right - determines the space to the right of an element.</li>
<li>top - determines the space above an element.</li>
<li>bottom - determines the space below an element.</li>
</ol>
<p>The spacing properties behave somewhat like margins, adding space around an element. </p>
<h2 id="size"><a class="header" href="#size">Size</a></h2>
<p>The size of an element is determined by two properties:</p>
<ol>
<li>width - determines the width of an element.</li>
<li>height - determines the height of an element.</li>
</ol>
<p>Like with all spacing and size properties, the value can be expressed in pixels, percentage, stretch, and auto.</p>
<p><strong>Pixels</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parent-properies-todo"><a class="header" href="#parent-properies-todo">Parent Properies (TODO)</a></h1>
<h2 id="layout-type"><a class="header" href="#layout-type">Layout Type</a></h2>
<p><strong>Rust</strong></p>
<pre><code class="language-rs">enum LayoutType {
    Row,
    Column,
    Grid,
}
</code></pre>
<p><strong>Stylesheet:</strong></p>
<pre><code class="language-css">.container {
    layout-type: row | column | grid;
}
</code></pre>
<p>This determines how the child elements should be arranged in the parent.</p>
<ul>
<li><strong>Row</strong> - Child elements are arranged into a horizontal stack from left to right</li>
<li><strong>Column</strong> - Child elements are arranged into a vertical stack from top to bottom</li>
<li><strong>Grid</strong> - Child elements are arranged into a grid (link here)</li>
</ul>
<h2 id="child-space"><a class="header" href="#child-space">Child-Space</a></h2>
<p>This determines the spacing around the elements in a stack (does not apply to grid). </p>
<p>Each of the child spacing properties (see below), defined on the parent, acts to override the auto-spaced properties of the child elements. For example, the parent <code>child-left</code> property will override the <code>left</code> property of a child element if the <code>left</code> property is set to <code>Units::Auto</code>.</p>
<p>There are five child-space properties:</p>
<ol>
<li><strong>child-left</strong> - determines the space to the left of the stack. Applies to the <em>first</em> element in a horizontal stack and <em>all</em> elements in a vertical stack.</li>
<li><strong>child-right</strong> - determines the space to the right of the stack. Applies to the <em>last</em> element in a horizontal stack and <em>all</em> elements in a vertical stack.</li>
<li><strong>child-top</strong> - determines the space to the top of the stack. Applies to the <em>first</em> element in a vertical stack and <em>all</em> elements in a horizontal stack.</li>
<li><strong>child-bottom</strong> - determines the space to the top of the stack. Applies to the <em>last</em> element in a vertical stack and <em>all</em> elements in a horizontal stack.</li>
<li><strong>child-between</strong> - determines the space between elements on the main axis. Applies to all elements except the first and last and acts to override child <code>left</code> and <code>right</code> spacing.</li>
</ol>
<p>With these child spacing properties it is possible to do a number of alignment configurations:</p>
<h4 id="align-left"><a class="header" href="#align-left">Align Left</a></h4>
<pre><code class="language-css">.container {
    child-left: 0px;
    child-right: 1s;
}
</code></pre>
<h4 id="align-center"><a class="header" href="#align-center">Align Center</a></h4>
<pre><code class="language-css">.container {
    child-left: 1s;
    child-right: 1s;
}
</code></pre>
<h4 id="align-right"><a class="header" href="#align-right">Align Right</a></h4>
<pre><code class="language-css">.container {
    child-left: 1s;
    child-right: 0px;
}
</code></pre>
<h4 id="align-top"><a class="header" href="#align-top">Align Top</a></h4>
<pre><code class="language-css">.container {
    child-top: 0px;
    child-bottom: 1s;
}
</code></pre>
<h4 id="align-middle"><a class="header" href="#align-middle">Align Middle</a></h4>
<pre><code class="language-css">.container {
    child-top: 1s;
    child-bottom: 1s;
}
</code></pre>
<h4 id="align-bottom"><a class="header" href="#align-bottom">Align Bottom</a></h4>
<pre><code class="language-css">.container {
    child-top: 1s;
    child-bottom: 0px;
}
</code></pre>
<h4 id="space-between"><a class="header" href="#space-between">Space Between</a></h4>
<pre><code class="language-css">.container {
    child-between: 1s;
}
</code></pre>
<h4 id="space-evenly-row"><a class="header" href="#space-evenly-row">Space Evenly (Row)</a></h4>
<pre><code class="language-css">.container {
    child-left: 1s;
    child-right: 1s;
    child-between: 1s;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="positioning-text-todo"><a class="header" href="#positioning-text-todo">Positioning Text (TODO)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Tuix has a built in system for generating and dispatching events to widgets in the hioerarchy. This is how widgets can respond to interaction, such as mouse clicks and keyboard presses, and also allows for widgets to communicate with each other.</p>
<p>Dispatched events are placed in a queue, and then the event manager sends the events to the relevant widgets which can respond by sending their own events. This process of receiving and sending events runs within a loop called the <em>Update Cycle</em> until there are no more events in the queue, at which point the application may redraw before waiting for the next OS event.</p>
<p>Unlike a game where the application is continuously updating and rerendering at a constant frame rate, a tuix application will only update when it receives an event from Operating System (except when an animation is playing). </p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>All events in tuix are wrapped in an<code>Event</code> type which contains meta data, such as the origin, target, and propagation type of the event, as well as the <strong>message</strong> which is a boxed dynamic <code>Message</code> object.</p>
<p>Any type which implments <code>Debug</code>, <code>Clone</code>, and <code>PartialEq</code> automatically implements the <code>Message</code> trait and can be used within an <code>Event</code>. For example:</p>
<pre><code class="language-rs">
// Can be used as a message
#[derive(Debug, Clone, PartialEq)]
pub enum CustomEvent {
    DoSomething,
    DoSomethingWithValue(String),
}

// Create a new event with a message of CustomEvent::DoSomething with a target of entity
let event = Event::new(CustomEvent::DoSomething).target(entity);
</code></pre>
<h2 id="event-propagation"><a class="header" href="#event-propagation">Event Propagation</a></h2>
<p>The propagation path determines which widgets will receive an event when it is dispatched by the event manager.</p>
<p>There are four types of event propagation:</p>
<ul>
<li><strong>DownUp</strong> - The event is sent from the root to the target and then back up to the root. This means that, unless the event is consumed, many widgets along the path, except for the target, will receive the event twice.</li>
<li><strong>Down</strong> - The event propagates down from the root to the target.</li>
<li><strong>Up</strong> - The event propagates up from the target to the root.</li>
<li><strong>Fall</strong> - The event propagates from the target down the branch to the last leaf widget.</li>
<li><strong>Direct</strong> - The event is sent directly to the target and no other widgets.</li>
</ul>
<h2 id="sending-events"><a class="header" href="#sending-events">Sending Events</a></h2>
<p>Sending or dispatching an event is the process of adding the event to the internal event queue within <code>State</code>.</p>
<p>The <code>insert_event()</code> method on <code>State</code> allows for an event to be added to the event queue. The origin, target, and propagation type should be specified on the event before adding it to the queue.</p>
<h3 id="convenience-functions"><a class="header" href="#convenience-functions">Convenience Functions</a></h3>
<p>Because the process of dispatching an event using the <code>insert_event()</code> method can be quite verbose, tuix provides a set of convenience methods for sending events with a particular target and propagation type and can be called directly on an entity, which then becomes the origin. </p>
<p>The following convenience functions take a message and generate the <code>Event</code> for you: </p>
<ul>
<li><code>entity.emit(message: impl Message)</code> - Sends an event with a message of <code>message</code>, with default propagation type (<code>DownUp</code>), and with <code>entity</code> as both the target and origin.</li>
<li><code>entity.emit_to(target: Entity)</code> - Sends an event with a message of <code>message</code>, with default propagation type (<code>DownUp</code>), with <code>target</code> as the target, and <code>entity</code> as the origin.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-propagation-1"><a class="header" href="#event-propagation-1">Event Propagation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-events"><a class="header" href="#handling-events">Handling Events</a></h1>
<p>Each update cycle, events in the queue will be dispatched to their target widgets. There are two primary methods for handling events sent to widgets:</p>
<ol>
<li>
<p><strong>Event Handlers</strong> allow for handling events in the same way for all intances of a particular widget type. For example, all button widgets should become 'active' when pressed.</p>
</li>
<li>
<p><strong>Callbacks</strong> allow for handling events on a per instance basis. For example, one button widget might trigger the window to close while another button might trigger the window to go fullscreen.</p>
</li>
</ol>
<h2 id="event-handlers"><a class="header" href="#event-handlers">Event Handlers</a></h2>
<p>To receive and respond to an event, a widget type must implement the <code>on_event()</code> method of the <code>Widget</code> trait.</p>
<p>Here is an example from the <code>Button</code> widget for responding to a left mouse button press on the widget:</p>
<pre><code class="language-rs">...
fn on_event(&amp;mut self, state: &amp;mut State, entity: Entity, event: &amp;mut Event) {
    
    if let Some(window_event) = event.message.downcast::&lt;WindowEvent&gt;() {
        match window_event {
            WindowEvent::MouseDown(button) if *button == MouseButton::Left =&gt; {
                // Code which runs when the left mouse button is pressed 
                // on the button widget (left out for brevity)
                ...
            }

            ...
        }
    }
}
...
</code></pre>
<p>Becuase the messages within events are boxed dynamic objects, the message must first be cast to the desired type with the <code>downcast()</code> method. Here we have specified the message type to cast to but Rust can actually infer this from the match statement that follows.</p>
<p>Once the message is the correct type, we can do things like match on the message type (if it's an enum) to respond to different message variants. In the above example the <code>WindowEvent</code> message contains a <code>MouseDown</code> variant which contains the mouse button which was pressed. A match guard is used to check if the mouse left button was pressed in which case it runs the contained code (left out for brevity).</p>
<p>Since the <code>on_event</code> method provides mutable access to the local properties of the widget, through <code>self</code>, and mutable access to the global state, through <code>state</code> using <code>entity</code>, there are a number of things that can be done within an event handler, including:</p>
<ul>
<li>Setting local widget properties through <code>self</code>.</li>
<li>Setting global widget properties through <code>state</code> using the widget <code>entity</code>.</li>
<li>Sending events.</li>
<li>Adding resources to State.</li>
</ul>
<h2 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h2>
<p>Callbacks are closures (functions), stored within a widget, which are triggered when a particular event is received. For example, the <code>Button</code> widget contains <code>on_press</code> and <code>on_release</code> callbacks which are triggered when the button is pressed (with the left nouse button) and released respectively.</p>
<p>Internally, this is acheived by handling the <code>WindowEvent::MouseDown</code> event within the event handler (<code>on_event</code> method) of the button which then calls the stored closures.</p>
<p>This example creates a new button with a callback which closes the window when pressed:</p>
<pre><code class="language-rs">Button::new()
    .on_press(|widget: &amp;mut Button, state: &amp;mut State, button: Entity| {
        button.emit(state, WindowEvent::CloseWindow);
    })
    .build(state, parent, |builder| builder);
</code></pre>
<p>For clarity, the closure argument types have been added. </p>
<p>A callback can have many forms but for the standard callbacks provided by the default widgets within tuix, the arguments to the closure mirror the arguments to the <code>on_event</code> method, allowing for the modification of local and global properties. </p>
<p>In the above example the first arguement is unused as no local properties are required. However, a widget such as the <code>Slider</code> contains the current value, which can be used within one of the callbacks of the slider, such as the <code>on_changing</code> callback:</p>
<pre><code class="language-rs">// Prints the current value of the slider while the slider value is changing,
// either by pressing the track or dragging the thumb along the track.
 Slider::new()
    .on_changing(|slider, state, entity| {
        entity.emit(WindowEvent::Debug(format!(&quot;Value: {}&quot;, slider.value)))
    })
    .build(state, parent, |builder| builder)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-events"><a class="header" href="#window-events">Window Events</a></h1>
<p>Events which are sent by the Operating System and are received by the appllication window are translated into a tuix <code>Event</code> with a <code>WindowEvent</code> message type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling"><a class="header" href="#styling">Styling</a></h1>
<p>Stlying elts us add properties to our widgets that change their visual appearance. Technically, layout propeties fall under styling as well, but for simplicity in learning the layout properties are detailed in a <a href="styling//layout/stack_overview.html">separate section of the book</a>.</p>
<h1 id="available-properties"><a class="header" href="#available-properties">Available Properties</a></h1>
<p>The table below shows the list of available style properties (layout properties are not shown for brevity). The property names are as they would appear in a css stylesheet. The property names in Rust are the same except dashes are replaced with underscores. For example, <code>background-color</code> in css becomes <code>background_color</code> in Rust.</p>
<table><thead><tr><th>Property</th><th>Value Type</th><th>Default Value</th><th>Animatable</th></tr></thead><tbody>
<tr><td>display</td><td>None | Flex</td><td>Flex</td><td>No</td></tr>
<tr><td>visibility</td><td>Visible | Invisible</td><td>Visible</td><td>No</td></tr>
<tr><td>opacity</td><td>f32 (0.0 - 1.0)</td><td>1.0</td><td>Yes</td></tr>
<tr><td>border-width</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-color</td><td>Color</td><td>Color::rgba(0,0,0,0)</td><td>Yes</td></tr>
<tr><td>border-radius</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-radius-top-left</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-radius-top-right</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-radius-bottom-left</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>border-radius-bottom-right</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>background-color</td><td>Color</td><td>Color::rgba(0,0,0,0)</td><td>Yes</td></tr>
<tr><td>background-gradient</td><td>LinearGradient</td><td></td><td>No</td></tr>
<tr><td>background-image</td><td>TODO</td><td></td><td>No</td></tr>
<tr><td>font</td><td>String</td><td></td><td>No</td></tr>
<tr><td>color</td><td>Color</td><td>Color::black()</td><td>Yes</td></tr>
<tr><td>font-size</td><td>f32</td><td>14.0</td><td>Yes</td></tr>
<tr><td>outer_shadow_h_offset</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>outer_shadow_v_offset</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>outer_shadow_blur</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>outer_shadow_color</td><td>Color</td><td>Color::rgba(0,0,0,0)</td><td>Yes</td></tr>
<tr><td>inner_shadow_h_offset</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>inner_shadow_v_offset</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>inner_shadow_blur</td><td>Units</td><td>Units::Auto</td><td>Yes</td></tr>
<tr><td>inner_shadow_color</td><td>Color</td><td>Color::rgba(0,0,0,0)</td><td>Yes</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-styling"><a class="header" href="#inline-styling">Inline Styling</a></h1>
<p>Inline properties refers to style and layout properties which are set on a per widget basis.</p>
<h2 id="setting-styles-on-entities"><a class="header" href="#setting-styles-on-entities">Setting styles on entities</a></h2>
<p>Style properties can be set on any widget by calling a property setter on its id. For example, to set the background color of a widget:</p>
<pre><code class="language-rs">entity.set_background_color(state, Color::blue());
</code></pre>
<p>where <code>entity</code> is the <code>Entity</code> id of the widget and <code>state</code> is a mutable reference to <code>State</code>. Property setters are available on the entity id thanks to the <code>PropSet</code> trait, which exposes setters for all of the style and layout properties.</p>
<h2 id="setting-styles-during-widget-building"><a class="header" href="#setting-styles-during-widget-building">Setting styles during widget building</a></h2>
<p>It is also possible to set the style properties of a widget when the widget is built using the <code>builder</code> argument of the supplied closure to the <code>build</code> method. For example, when building a <code>Button</code> instance we can set its background color like so:</p>
<pre><code class="language-rs">let button = Button::new().build(state, parent, |builder| 
    builder
        .set_background_color(Color::blue())
);
</code></pre>
<p>The name of the setter is identical to the one used on an entity id, except now a mutable reference to <code>State</code> is not required because there is one internal to the builder.</p>
<p>Note that the widget being acted upon when setting properties on the builder may not be the same widget as the one referred to by the returned entity id.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-styling"><a class="header" href="#shared-styling">Shared Styling</a></h1>
<p>Tuix provides a way to define styles which can be shared between several widgets. This can reduce both complexity and memory usage since only the style data is stored in memory.</p>
<p>Shared styles in tuix follow the same rules as css stylesheets, with selectors determining which widgets are affected by which style rules. This section covers how to define shared styles in tuix. For an overview of selectors, see the <a href="styling/">next section.</a>.</p>
<h2 id="style-rules-in-rust"><a class="header" href="#style-rules-in-rust">Style Rules in Rust</a></h2>
<p>TODO</p>
<h2 id="stylsheets"><a class="header" href="#stylsheets">Stylsheets</a></h2>
<p>An easier way to define shared styles is with the use of css. While tuix can parse a string or file containing css, not that many of the features of css are not supported, inlcuding the cascading which gives css a part of its name.</p>
<p>To add a css string to tuix, call <code>state.add_theme(css_string: &amp;str)</code>. Tuix will then parse the supplied string for style rules and add them to the application. The css string can be defined as a constant, for example:</p>
<pre><code class="language-rs">const STYLE: &amp;str = #r&quot;
    button {
        width: 100px;
        height: 30px;
        background-color: red;
    }
&quot;#
</code></pre>
<p>Or the css string can be included from a file using the <code>include_str!()</code> macro. For example:</p>
<pre><code class="language-rs">const STYLE: &amp;str = include_str!(&quot;path_to_css_file&quot;);
</code></pre>
<p>Then, to include the styles in the tuix application call:</p>
<pre><code class="language-rs">state.add_theme(STYLE);
</code></pre>
<h3 id="hot-reloading-of-stylesheets"><a class="header" href="#hot-reloading-of-stylesheets">Hot Reloading of Stylesheets</a></h3>
<p>Inlcuding the css string as a constant means that it cannot be updated while the program is running.</p>
<p>Tuix provides another method of including an external stylesheet within a .css file which can be modified and reloaded. To add a reloadable stylesheet call <code>state.add_stylesheet(path_to_css_file)</code>. This will load the contents of the file and parse any style rules. To reload the stylsheet while the application is running, press the F5 key.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="display-properties"><a class="header" href="#display-properties">Display Properties</a></h1>
<p>There are three properties which affect whether a widget is displayed or not:</p>
<ol>
<li>display</li>
<li>visibility</li>
<li>opacity</li>
</ol>
<h2 id="display"><a class="header" href="#display">Display</a></h2>
<p>The <code>display</code> property determines whether or not a widget is included within both layout and rendering. The <code>display</code> property can be set to either <code>none</code> (<code>Display::None</code>), or <code>flex</code> (<code>Display::Flex</code>) which is the default. If the <code>display</code> property is set to <code>none</code> then the widget will not be included in layout and will not be rendered.</p>
<h2 id="visibility"><a class="header" href="#visibility">Visibility</a></h2>
<p>The <code>visibility</code> property affects only whether a widget will be included during rendering. Unlike <code>display</code>, the <code>visibility</code> of a widget does <em>not</em> affect layout. The <code>visibility</code> property can be set to either <code>visible</code> (<code>Visibility::Visible</code>), the default, or `</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background"><a class="header" href="#background">Background</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="border"><a class="header" href="#border">Border</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadows"><a class="header" href="#shadows">Shadows</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
